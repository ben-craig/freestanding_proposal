<!DOCTYPE html>
<html>
<style type="text/css">
  ins, ins * { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  del, del * { text-decoration:line-through; background-color:#FFA0A0 }
  #hidedel:checked ~ * del, #hidedel:checked ~ * del * { display:none; visibility:hidden }

blockquote {
  padding: .5em;
  border: .5em;
  border-color: silver;
  border-left-style: solid;
}

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5em; padding-right: 0.5em; }

p.grammarlhs { margin-bottom: 0 }
p.grammarrhs { margin-left:8em; margin-top:0; margin-bottom:0; text-indent:-4em }

div.wrapper {
    max-width: 60em;
    margin: auto;
}

a { text-decoration: none; }

a.hidden_link {
    text-decoration: none;
    color: inherit;
}

li {
    margin-top: 0.6em;
    margin-bottom: 0.6em;
}

h1 { line-height: 1; }
h2 { line-height: 1; }
h3 { line-height: 1; }
h4 { line-height: 1; }

:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }

.abbr_ref { float: right; }

.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }

:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }

.secnum { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }

div.sourceLinkParent {
    float: right;
}

a.sourceLink {
    position: absolute;
    opacity: 0;
    margin-left: 10pt;
}

a.sourceLink:hover {
    opacity: 1;
}

div.marginalizedparent {
    position: relative;
    left: -5em;
}

div.footnoteNumberParent {
    position: relative;
    left: -4.7em;
}

a.marginalized {
    position: absolute;
    font-size: 75%;
    text-align: right;
    width: 5em;
}

a.enumerated_item_num {
    position: relative;
    left: -3.5em;
    display: inline-block;
    margin-right: -3em;
    text-align: right;
    width: 3em;
}

div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }

span.indexparent {
    display: inline;
    position: relative;
    float: right;
    right: -1em;
}

a.index {
    position: absolute;
    display: none;
}

a.index:before { content: "âŸµ"; }
    /* this way the content is not selectable */

a.index:target {
    display: inline;
}

.indexitems {
    margin-left: 2em;
    text-indent: -2em;
}

div.itemdescr {
    margin-left: 3em;
}

.bnf {
    font-family: serif;
    margin-left: 40pt;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}

.ncbnf {
    font-family: serif;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 40pt;
}

.bnftab {
    font-family: serif;
    font-style: italic;
    margin-left: 40pt;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}

.ncsimplebnf {
    font-family: serif;
    font-style: italic;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 40pt;
}

.ncbnftab {
    font-family: serif;
    font-style: italic;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 40pt;
}

.bnfkeywordtab {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 40pt;
}

span.textnormal {
    font-style: normal;
    font-family: serif;
    white-space: normal;
    display: inline-block;
}

span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }

span.phantom { color: white; }
    /* Unfortunately, this way the text is still selectable. Another
    option is display:none, but then we lose the nice layout.
    Todo: find proper solution. */

span.math { }

span.mathblock {
    display: block;
    margin-left: auto;
    margin-right: auto;
    margin-top: 1.2em;
    margin-bottom: 1.2em;
    text-align: center;
}

span.mathalpha {
    font-style: italic;
}

span.synopsis {
    font-weight: bold;
    margin-top: 0.5em;
    display: block;
}

span.definition {
    font-weight: bold;
    display: block;
}

.codeblock {
    margin-left: 1.2em;
    line-height: 127%;
}

code {
    font-family: monospace;
    font-style: normal;
}

code.itemdecl {
    margin-top: 2ex;
    white-space: pre;
    display: block;
}

.comment {
    font-style: italic;
    font-family: serif;
}

span.textsuperscript {
    vertical-align: super;
    font-size: smaller;
    line-height: 0;
}

.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }

.footnote {
    font-size: small;
    margin-left: 2em;
    margin-right: 2em;
    margin-top: 0.6em;
    margin-bottom: 0.6em;
}

div.minipage {
    display: inline-block;
    margin-right: 3em;
}

div.numberedTable {
    text-align: center;
    margin: 2em;
}

div.figure {
    text-align: center;
    margin: 2em;
}

table {
    border: 1px solid black;
    border-collapse: collapse;
    margin-left: auto;
    margin-right: auto;
    margin-top: 0.8em;
    text-align: left;
    hyphens: none; /* otherwise some columns get very narrow, e.g. [tab:hash] */
}

td, th {
    padding-left: 1em;
    padding-right: 1em;
    vertical-align: top;
}

td.left {
    text-align: left;
}

td.right {
    text-align: right;
}

td.center {
    text-align: center;
}

td.justify {
    text-align: justify;
}

td.border {
    border-left: 1px solid black;
}

tr.rowsep, td.cline {
    border-top: 1px solid black;
}

tr.capsep {
    border-top: 3px solid black;
    border-top-style: double;
}

th {
    border-bottom: 1px solid black;
}

span.centry {
    font-weight: bold;
}

div.table {
    display: block;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
    width: 90%;
}

span.indented {
    display: block;
    margin-left: 2em;
    margin-bottom: 1em;
    margin-top: 1em;
}

ol.enumeratea { list-style-type: none; }

ol.enumerate { list-style-type: none; }
.mjx-chtml {display: inline-block; line-height: 0; text-indent: 0; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 100%; font-size-adjust: none; letter-spacing: normal; word-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; margin: 0; padding: 1px 0}
.MJXc-display {display: block; text-align: center; margin: 1em 0; padding: 0}
.mjx-chtml[tabindex]:focus, body :focus .mjx-chtml[tabindex] {display: inline-table}
.mjx-full-width {text-align: center; display: table-cell!important; width: 10000em}
.mjx-math {display: inline-block; border-collapse: separate; border-spacing: 0}
.mjx-math * {display: inline-block; -webkit-box-sizing: content-box!important; -moz-box-sizing: content-box!important; box-sizing: content-box!important; text-align: left}
.mjx-numerator {display: block; text-align: center}
.mjx-denominator {display: block; text-align: center}
.MJXc-stacked {height: 0; position: relative}
.MJXc-stacked > * {position: absolute}
.MJXc-bevelled > * {display: inline-block}
.mjx-stack {display: inline-block}
.mjx-op {display: block}
.mjx-under {display: table-cell}
.mjx-over {display: block}
.mjx-over > * {padding-left: 0px!important; padding-right: 0px!important}
.mjx-under > * {padding-left: 0px!important; padding-right: 0px!important}
.mjx-stack > .mjx-sup {display: block}
.mjx-stack > .mjx-sub {display: block}
.mjx-prestack > .mjx-presup {display: block}
.mjx-prestack > .mjx-presub {display: block}
.mjx-delim-h > .mjx-char {display: inline-block}
.mjx-surd {vertical-align: top}
.mjx-mphantom * {visibility: hidden}
.mjx-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 2px 3px; font-style: normal; font-size: 90%}
.mjx-annotation-xml {line-height: normal}
.mjx-menclose > svg {fill: none; stroke: currentColor}
.mjx-mtr {display: table-row}
.mjx-mlabeledtr {display: table-row}
.mjx-mtd {display: table-cell; text-align: center}
.mjx-label {display: table-row}
.mjx-box {display: inline-block}
.mjx-block {display: block}
.mjx-span {display: inline}
.mjx-char {display: block; white-space: pre}
.mjx-itable {display: inline-table; width: auto}
.mjx-row {display: table-row}
.mjx-cell {display: table-cell}
.mjx-table {display: table; width: 100%}
.mjx-line {display: block; height: 0}
.mjx-strut {width: 0; padding-top: 1em}
.mjx-vsize {width: 0}
.MJXc-space1 {margin-left: .167em}
.MJXc-space2 {margin-left: .222em}
.MJXc-space3 {margin-left: .278em}
.mjx-ex-box-test {position: absolute; width: 1px; height: 60ex}
.mjx-line-box-test {display: table!important}
.mjx-line-box-test span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}
.MJXc-TeX-unknown-R {font-family: monospace; font-style: normal; font-weight: normal}
.MJXc-TeX-unknown-I {font-family: monospace; font-style: italic; font-weight: normal}
.MJXc-TeX-unknown-B {font-family: monospace; font-style: normal; font-weight: bold}
.MJXc-TeX-unknown-BI {font-family: monospace; font-style: italic; font-weight: bold}
.MJXc-TeX-ams-R {font-family: MJXc-TeX-ams-R,MJXc-TeX-ams-Rw}
.MJXc-TeX-cal-B {font-family: MJXc-TeX-cal-B,MJXc-TeX-cal-Bx,MJXc-TeX-cal-Bw}
.MJXc-TeX-frak-R {font-family: MJXc-TeX-frak-R,MJXc-TeX-frak-Rw}
.MJXc-TeX-frak-B {font-family: MJXc-TeX-frak-B,MJXc-TeX-frak-Bx,MJXc-TeX-frak-Bw}
.MJXc-TeX-math-BI {font-family: MJXc-TeX-math-BI,MJXc-TeX-math-BIx,MJXc-TeX-math-BIw}
.MJXc-TeX-sans-R {font-family: sans-serif}
.MJXc-TeX-sans-B {font-family: MJXc-TeX-sans-B,MJXc-TeX-sans-Bx,MJXc-TeX-sans-Bw}
.MJXc-TeX-sans-I {font-family: MJXc-TeX-sans-I,MJXc-TeX-sans-Ix,MJXc-TeX-sans-Iw}
.MJXc-TeX-script-R {font-family: MJXc-TeX-script-R,MJXc-TeX-script-Rw}
.MJXc-TeX-type-R {font-family: monospace}
.MJXc-TeX-cal-R {font-family: MJXc-TeX-cal-R,MJXc-TeX-cal-Rw}
.MJXc-TeX-main-B {font-family: MJXc-TeX-main-B,MJXc-TeX-main-Bx,MJXc-TeX-main-Bw}
.MJXc-TeX-main-I {font-style: italic}
.MJXc-TeX-main-R {}
.MJXc-TeX-math-I {font-style: italic}
.MJXc-TeX-size1-R {font-family: MJXc-TeX-size1-R,MJXc-TeX-size1-Rw}
.MJXc-TeX-size2-R {font-family: MJXc-TeX-size2-R,MJXc-TeX-size2-Rw}
.MJXc-TeX-size3-R {font-family: MJXc-TeX-size3-R,MJXc-TeX-size3-Rw}
.MJXc-TeX-size4-R {font-family: MJXc-TeX-size4-R,MJXc-TeX-size4-Rw}
@font-face {font-family: MJXc-TeX-ams-R; src: local('MathJax_AMS'), local('MathJax_AMS-Regular')}
@font-face {font-family: MJXc-TeX-ams-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_AMS-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_AMS-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_AMS-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-cal-B; src: local('MathJax_Caligraphic Bold'), local('MathJax_Caligraphic-Bold')}
@font-face {font-family: MJXc-TeX-cal-Bx; src: local('MathJax_Caligraphic'); font-weight: bold}
@font-face {font-family: MJXc-TeX-cal-Bw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Caligraphic-Bold.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Bold.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Bold.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-frak-R; src: local('MathJax_Fraktur'), local('MathJax_Fraktur-Regular')}
@font-face {font-family: MJXc-TeX-frak-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Fraktur-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Fraktur-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Fraktur-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-frak-B; src: local('MathJax_Fraktur Bold'), local('MathJax_Fraktur-Bold')}
@font-face {font-family: MJXc-TeX-frak-Bx; src: local('MathJax_Fraktur'); font-weight: bold}
@font-face {font-family: MJXc-TeX-frak-Bw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Fraktur-Bold.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Fraktur-Bold.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Fraktur-Bold.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-math-BI; src: local('MathJax_Math BoldItalic'), local('MathJax_Math-BoldItalic')}
@font-face {font-family: MJXc-TeX-math-BIx; src: local('MathJax_Math'); font-weight: bold; font-style: italic}
@font-face {font-family: MJXc-TeX-math-BIw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Math-BoldItalic.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Math-BoldItalic.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Math-BoldItalic.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-sans-R; src: local('MathJax_SansSerif'), local('MathJax_SansSerif-Regular')}
@font-face {font-family: MJXc-TeX-sans-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_SansSerif-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-sans-B; src: local('MathJax_SansSerif Bold'), local('MathJax_SansSerif-Bold')}
@font-face {font-family: MJXc-TeX-sans-Bx; src: local('MathJax_SansSerif'); font-weight: bold}
@font-face {font-family: MJXc-TeX-sans-Bw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_SansSerif-Bold.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Bold.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Bold.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-sans-I; src: local('MathJax_SansSerif Italic'), local('MathJax_SansSerif-Italic')}
@font-face {font-family: MJXc-TeX-sans-Ix; src: local('MathJax_SansSerif'); font-style: italic}
@font-face {font-family: MJXc-TeX-sans-Iw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_SansSerif-Italic.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Italic.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Italic.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-script-R; src: local('MathJax_Script'), local('MathJax_Script-Regular')}
@font-face {font-family: MJXc-TeX-script-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Script-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Script-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Script-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-type-R; src: local('MathJax_Typewriter'), local('MathJax_Typewriter-Regular')}
@font-face {font-family: MJXc-TeX-type-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Typewriter-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Typewriter-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Typewriter-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-cal-R; src: local('MathJax_Caligraphic'), local('MathJax_Caligraphic-Regular')}
@font-face {font-family: MJXc-TeX-cal-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Caligraphic-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-main-B; src: local('MathJax_Main Bold'), local('MathJax_Main-Bold')}
@font-face {font-family: MJXc-TeX-main-Bx; src: local('MathJax_Main'); font-weight: bold}
@font-face {font-family: MJXc-TeX-main-Bw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Main-Bold.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-main-I; src: local('MathJax_Main Italic'), local('MathJax_Main-Italic')}
@font-face {font-family: MJXc-TeX-main-Ix; src: local('MathJax_Main'); font-style: italic}
@font-face {font-family: MJXc-TeX-main-Iw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Main-Italic.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-main-R; src: local('MathJax_Main'), local('MathJax_Main-Regular')}
@font-face {font-family: MJXc-TeX-main-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Main-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-math-I; src: local('MathJax_Math Italic'), local('MathJax_Math-Italic')}
@font-face {font-family: MJXc-TeX-math-Ix; src: local('MathJax_Math'); font-style: italic}
@font-face {font-family: MJXc-TeX-math-Iw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Math-Italic.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-size1-R; src: local('MathJax_Size1'), local('MathJax_Size1-Regular')}
@font-face {font-family: MJXc-TeX-size1-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Size1-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-size2-R; src: local('MathJax_Size2'), local('MathJax_Size2-Regular')}
@font-face {font-family: MJXc-TeX-size2-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Size2-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-size3-R; src: local('MathJax_Size3'), local('MathJax_Size3-Regular')}
@font-face {font-family: MJXc-TeX-size3-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Size3-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-size4-R; src: local('MathJax_Size4'), local('MathJax_Size4-Regular')}
@font-face {font-family: MJXc-TeX-size4-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Size4-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf') format('opentype')}
</style>

<body>
<h1>Freestanding Proposal</h1>
Document number: D0829R2.0<br/>
Date: 2017-10-14<br/>
Reply-to: Ben Craig &lt;ben dot craig at gmail dot com&gt;<br/>
Audience: SG14, Library Evolution Working Group
<h1>Change history</h1>
<h2> R1 -&gt; R2 </h2>
Removed <code>atoi</code> because of reliance on <code>isspace</code>.<br/>
Added <code>visit</code> and <code>bad_variant_access</code>.<br/>
Added <code>bitset</code>, minus the string members and throwing members.<br/>
Added <code>&lt;version&gt;</code> and moved the feature macro there.<br/>
Added <code>unique_ptr</code>.  Leaving <code>make_unique</code> and <code>default_delete</code> out.<br/>
TODO: Add span<br/>
<h2> R0 -&gt; R1 </h2>
R1 adds an abstract.<br/>
R1 no longer removes any existing freestanding libraries.<br/>
R1 no longer gives implementations freedom to add <code>static_assert</code>s to allocation functions in freestanding mode.<br/>
<code>unique_ptr</code> is no longer included in freestanding, with the hopes that <code>unique_resource</code> and <code>scope_exit</code> will fill the void<br/>
R1 adds naming alternatives for freestanding.<br/>
R1 includes substantially less of <code>&lt;random&gt;</code>, and white-lists inclusions rather than black-lists omissions.<br/>
R1 adds some allocator machinery, though it does not add the default allocator.<br/>
R1 adds <code>&lt;compare&gt;</code>, as it seems to have been accidentally omitted from the freestanding headers list.<br/>
R1 adds large portions of <code>&lt;chrono&gt;</code>, <code>&lt;optional&gt;</code>, and <code>&lt;variant&gt;</code>.<br/>
R1 adds a feature test macro.
<h1>Abstract</h1>
Add everything to the freestanding implementation that can be implemented without OS calls and space overhead.
<h1>Introduction</h1>
<p>
The current definition of the freestanding implementation is not very useful.  Here is the current high level definition from [intro.compliance]:
<blockquote>7 Two kinds of implementations are defined: a hosted implementation and a freestanding implementation. For a
hosted implementation, this document defines the set of available libraries. A freestanding implementation is
one in which execution may take place without the benefit of an operating system, and has an implementation defined
set of libraries that includes certain language-support libraries (20.5.1.3).</blockquote>
<p>
The main people served by the current freestanding definition are people writing their own hosted C++ standard library to sit atop the compiler author's freestanding implementation (i.e. the STLport use case).  The freestanding portions contain all the functions and types known to the compiler that can't easily be authored in a cross-compiler manner.
</p><p>
The current set of freestanding libraries provides too little to kernel and embedded programmers.  Why should a systems programmer need to rewrite <code>std::sort()</code> or <code>std::memcpy()</code>?
</p><p>
I propose we provide the (nearly) maximal subset of the library that does not require an OS or space overhead.  In order to continue supporting the "layered" C++ standard library users, we will continue to provide the (nearly) minimal subset of the library needed to support all the language features, even if these features have space overhead.  Language features requiring space overhead or OS support will remain intact.
</p>
<h1>Motivation</h1>
<p>
Systems programmers want to sort things.  They want to use move semantics.  They may even want to bundle the arguments of a variadic template function into a <code>std::tuple</code>.  These are all reasonable things to do on a system with no operating system and kilobytes of storage.  The C++ standard even has reasonable specifications for these operations in the context of a tiny, OS-less system.  However, systems programmers must currently rely on either hand-rolled code or implementer extensions in order to get these facilities.
</p><p>
Systems programmers don't have a guide as to what C++ library facilities will work without trying them.  The standard says <code>atomic_load</code> will work; <code>memcpy</code> will probably work; but will <code>stable_sort</code>?  Standardizing the subset of implementable C++ that is usable in a freestanding environment would provide clarity here, and help to educate systems programmers.
</p>
<h1>Current State</h1>
<p>
There were some presentations at recent CppCons where others made a more full featured C++ work in the Linux and Windows kernels [Quinn2016] [Baker2017].  In both of these cases, C++ was being used in a sandboxed / pseudo-virtualized way.  C++ code (with exceptions and RTTI) was being run in the kernel context, but very few calls were made between the C++ code and the operating system kernel.  The C++ code was in a guest operating system.  This proposal should make it reasonable to have C++ code interact closely with the internals of a host operating system, perhaps in the context of a driver.
</p><p>
The Microsoft Windows kernel and Apple Mac OSX kernel both currently support limited, non-compliant subsets of C++ for driver writers.  The Linux kernel does not support C++ officially, though with a fair amount of work on the part of the driver developer, C++ can be made to work.  Drivers written in C++ are highly unlikely to be accepted in the upstream Linux source repositories.
</p><p>
IncludeOS [Bratterud2017] is an OS primarily intended for running in VMs, though some bare metal support has been tested.  One might expect such a project to use a freestanding implementation as a base, but instead, it starts with a hosted implmentation of C++ and drops support for the impractical parts (threads and filestreams in particular).
</p><p>
Out of libstdc++, libc++, and Microsoft's Visual Studio STL, only libstdc++ has any relevant mention of "freestanding" or "hosted".  In practice, users take a hosted implementation of C++ and use it as-is in situations where it was never intended.  This means that all the headers tend to be available, but only a few of the headers actually work.  Many of the headers that work aren't marked freestanding.  Some headers have parts that could work, except they are mixed with other parts that won't work.  For example, <code>iterator_traits</code> in <code>&lt;iterator&gt;</code> is fine, but the implementation details of the stream iterators cause build errors with the <code>/kernel</code> flag in Microsoft Visual Studio 2017.
</p>
<h1>Scope</h1>
<p>
The current scope of this proposal is limited to the freestanding standard library available to systems and embedded programming.
</p><p>
This paper is currently concerned with the divisions of headers and library functions as they were in C++17.  <a href="http://wg21.link/p0581">"Standard Library Modules" (P0581)</a> discusses how the library will be split up in a post-modules world.  This paper may influence the direction of P0581, but this paper won't make any modules recommendations.
</p><p>
I could see the scope increasing to the availability of the standard library on GPUs.
</p><p>
<h1>Impact on the standard</h1>
<p>
The standard will no longer list all of the facilities available to the freestanding implementation, as is currently done in [compliance].  Instead, [compliance] will list all the headers that are required to be present, and the header and class synopses will tag which parts of the headers and classes will be available.  This is a large number of small, easy to understand edits, along with the addition of a sub-clause that discusses how the tagging works.
</p><p>
There is precedent for this kind of tagging in other specification documents.  The ECMAScript Language Specification has optional support for ECMA-402 (internationalization).  The impact of ECMA-402 is called out explicitly in several places.  POSIX tags functions as supported in base, XSI, or in one of many option groups.
</p><p>
There were some conversations in the 2017 Albuquerque meeting around adding another class of conforming implementation.  I believe that such an action would be a mistake.  Maintaining two classifications is difficult enough as is, and freestanding is often neglected.  Adding another classification would magnify these problems.  I also feel that the freestanding classification should be removed if no action is taken to make it more useful.
</p>
<h2>Naming alternatives</h2>
<p>
There was some desire to come up with a new name for "freestanding" in the 2017 Albuquerque meeting.  This new name could better express the intended audience of such an implementation.  My current recommendation will be to keep the name "freestanding", but I will suggest some alternatives just the same.
</p>
<ul>
<li>backless</li>
<li>barebones</li>
<li>basic</li>
<li>embedded</li>
<li>foundational</li>
<li>freestanding</li>
<li>fundamental</li>
<li>independent</li>
<li>kernel</li>
<li>minimal</li>
<li>OS-free</li>
<li>OS-less</li>
<li>reduced</li>
<li>resource-constrained</li>
<li>skeleton</li>
<li>standalone</li>
<li>stripped</li>
<li>system-free</li>
<li>unsupported</li>
</ul>

<h1>Impact on implementations</h1>
<p>
C++ standard library headers will likely need to add preprocessor feature toggles to portions of headers that would emit warnings or errors in freestanding mode.  The precision and timeliness (compile time vs. link time) of errors remains a quality-of-implementation detail.
</p><p>
A minimal freestanding C11 standard library will not be sufficient to provide the C portions of the C++ standard library.  <code>std::char_traits</code> and many of the function specializations in <code>&lt;algorithm&gt;</code> are implemented in terms of non-freestanding C functions.  In practice, most C libraries are not minimal freestanding C11 libraries.  The optimized versions of the <code>&lt;cstring&gt;</code> and <code>&lt;cwchar&gt;</code> functions will typically be the same for both hosted and freestanding environments.
</p><p>
My expectation is that no new freestanding library will be authored as a result of this paper.  Instead hosted libraries will be stripped down through some feature toggle mechanism to become freestanding.
</p>
<h1>Design decisions</h1>
<p>
Even more so than for a hosted implementation, systems and embedded programmers do not want to pay for what they don't use.  As a consequence, I am not adding features that require global storage, even if that storage is immutable.
</p><p>
Note that the following concerns are not revolving around execution time performance.  These are generally concerns about space overhead and correctness.
</p><p>
This proposal doesn't remove problematic features from the language, but it does make it so that the bulk of the freestanding standard library doesn't require those features.  Users that disable the problematic features (as is existing practice) will still have portable portions of the standard library at their disposal.
</p><p>
Note that we cannot just take the list of <code>constexpr</code> or conditionally <code>noexcept</code> functions and make those functions the freestanding subset.  We also can't do the reverse, and make everything freestanding <code>constexpr</code> or conditionally <code>noexcept</code>.  <code>memcpy</code> cannot currently be made <code>constexpr</code> because it must convert from <code>cv void*</code> to <code>unsigned char[]</code>.  Several floating point functions could be made <code>constexpr</code>, but would not be permitted in freestanding.  The "Lakos Rule"[Meredith11] prohibits standard library functions from being <code>noexcept</code>, unless they have a wide contract.  Regardless, if a function or class is <code>constexpr</code> or <code>noexcept</code>, and it doesn't involve floating point, then that function or class is a strong candidate to be put into freestanding mode.
</p><p>
In the future, it may make sense to allow all <code>constexpr</code> functions into freestanding, so long as they are used in a <code>constexpr</code> context and not invoked at runtime.
</p>
<h2>Exceptions</h2>
<p>
Exceptions either require external jump tables or extra bookkeeping instructions.  This consumes program storage space.
</p><p>
In the Itanium ABI, throwing an exception requires a heap allocation.  In the Microsoft ABI, re-throwing an exception will consume surprisingly large amounts of stack space (2,100 bytes for a re-throw in 32-bit environments, 9,700 bytes in a 64-bit environment).  Program storage space, heap space, and stack space are typically scarce resources in embedded development.
</p><p>
In environments with threads, exception handling requires the use of thread-local storage.
</p>
<h2>RTTI</h2>
RTTI requires extra data in vtables and extra classes that are difficult to optimize away, consuming program storage space.
<h2>Thread-local storage</h2>
Thread-local storage requires extra code in the operating system for support.  In addition, if one thread uses thread-local storage, that cost is imposed on other threads.
<h2>The heap</h2>
The heap is a big set of global state.  In addition, heap exhaustion is typically expressed via exception.  Some embedded systems don't have a heap.  In kernel environments, there is typically a heap, but there isn't a reasonable choice of <i>which</i> heap to use as the default.  In the Windows kernel, the two best candidates for a default heap are the paged pool (plentiful available memory, but unsafe to use in many contexts), and the non-paged pool (safe to use, but limited capacity).  The C++ implementation in the Windows kernel forces users to implement their own global <code>operator new</code> to make this decision.
<h2>Floating point</h2>
<p>
Many embedded systems don't have floating point hardware.  Software emulated floating point can drag in large runtimes that are difficult to optimize away.
</p><p>
Most operating systems speed up system calls by not saving and restoring floating point state.  That means that kernel uses of floating point operations require extra care to avoid corrupting user state.
</p>
<h2>Functions requiring global or thread-local storage</h2>
These functions have been omitted or removed from the freestanding library.  Examples are the locale aware functions and the C random number functions.</li>
<h2>Parallel algorithms</h2>
For the <code>&lt;algorithms&gt;</code>, <code>&lt;numeric&gt;</code>, and <code>&lt;memory&gt;</code> headers, we would only be able to support sequential execution of parallel algorithms.  Since this adds little value, the execution policy overloads will be omitted.
<h2>Partial class inclusion</h2>
<p>
Some classes are only partially freestanding.  In the Albuquerque 2017 meeting, there was no consensus on allowing or prohibiting this (SF F N A SA 0 9 3 5 1).
</p><p>
In this proposal, I partially include three classes: <code>std::array</code>, <code>std::string_view</code>, and <code>std::optional</code>.  If we were designing these classes from scratch with a freestanding environment in mind, they would have the exact same layout and the exact same interface, with the exception of the excluded methods.  I think it is highly unlikely that the committee would standardize a <code>std::freestanding_array</code> that was the exact same as <code>std::array</code>, just without the <code>at()</code> method.
</p><p>
I would like to call out <code>std::variant</code> as well.  While I do include the entire class, I do exclude the <code>get()</code> function.  <code>get()</code> is logically part of the interface.  The same general argument I used for <code>std::array</code>, <code>std::string_view</code>, and <code>std::optional</code> holds for <code>std::variant</code>.
</p>
<h1>Technical Specifications</h1>
<h2>Complete headers newly required for freestanding implementations</h2>
<code><ul>
<li>&lt;utility&gt;</li>
<li>&lt;tuple&gt;</li>
<li>&lt;ratio&gt;</li>
<li>&lt;compare&gt;</li>
</ul></code>
<h2>Partial headers newly required for freestanding implementations</h2>
Portions of <code>&lt;cstdlib&gt;</code>
<ul>
<code><li>size_t</li>
<li>div_t</li>
<li>ldiv_t</li>
<li>lldiv_t</li>
<li>NULL</li>
<li>EXIT_FAILURE</li>
<li>EXIT_SUCCESS</li>
<li>_Exit</li>
<li>bsearch</li>
<li>qsort</li>
<li>abs(int)</li>
<li>abs(long int)</li>
<li>abs(long long int)</li>
<li>labs</li>
<li>llabs</li>
<li>div</li>
<li>ldiv</li>
<li>lldiv</li></code>
</ul>
<p>
All the error <code>#defines</code> in <code>&lt;cerrno&gt;</code>, but not <code>errno</code>.
</p><p>
The <code>errc</code> enum from <code>&lt;system_error&gt;</code>.
</p><p>
All of <code>&lt;optional&gt;</code>, except for <code>bad_optional_access</code> and <code>optional::value</code>.  The <code>optional</code> value can be accessed through the unchecked observers, <code>operator*</code> and <code>operator-&gt;</code>.
</p><p>
All of <code>&lt;variant&gt;</code>, except for <code>get</code>.  The <code>variant</code> value can be accessed through <code>get_if</code>.
</p><p>
All of <code>&lt;bitset&gt;</code> except for operator&lt;&lt;; operator&gt;&gt;; bitset::to_string; the bitset string constructors; and the indexed versions of bitset::set, bitset::reset, and bitset::flip.
</p><p>
Portions of <code>&lt;memory&gt;</code>.
</p>
<ul>
<li><code>pointer_traits</code></li>
<li><code>to_address</code></li>
<li><code>align</code></li>
<li><code>allocator_arg_t</code></li>
<li><code>allocator_arg</code></li>
<li><code>uses_allocator</code></li>
<li><code>allocator_traits</code></li>
<li>23.10.11, specialized algorithms, except for the ExecutionPolicy overloads</li>
<li><code>unique_ptr</code></li>
Note that <code>default_delete</code> is not included, and wording has been added to allow the default deleter of <code>unique_ptr</code> to be implementation defined on freestanding implementations.
<li><code>uses_allocator_v</code></li>
</ul>
<p>
Most of <code>&lt;functional&gt;</code>.  <b>Omit</b> the following.
<ul>
<li>23.14.13, polymorphic function wrappers (i.e. <code>std::function</code> and friends).</li>
<li>23.14.14.2, <code>boyer_moore_searcher</code></li>
<li>23.14.14.3, <code>boyer_moore_horspool_searcher</code></li>
</ul>
</p><p>
Most of <code>&lt;chrono&gt;</code>.  <b>Omit</b> 23.17.7, Clocks.
</p><p>
Portions of <code>&lt;charconv&gt;</code>.
</p>
<ul>
<li><code>to_chars_result</code></li>
<li><code>from_chars_result</code></li>
<li><code>to_chars</code>(integral)</li>
<li><code>from_chars</code>(integral)</li>
</ul>
<p>
The <code>char_traits</code> class from <code>&lt;string&gt;</code>.
</p><p>
Most of <code>&lt;string_view&gt;</code>.  These functions will be <b>omitted</b>:
</p>
<ul>
<code><li>operator&lt;&lt;</li>
<li>basic_string_view::at</li>
<li>basic_string_view::copy</li>
<li>basic_string_view::substr</li>
<li>basic_string_view::compare(size_type pos1, size_type n1, basic_string_view s);
<li>basic_string_view::compare(size_type pos1, size_type n1, basic_string_view s,
size_type pos2, size_type n2);
<li>basic_string_view::compare(size_type pos1, size_type n1, const charT* s);
<li>basic_string_view::compare(size_type pos1, size_type n1, const charT* s,
size_type n2);
</code></ul><p>
Portions of <code>&lt;cstring&gt;</code>.
<ul>
<code><li>memcpy</li>
<li>memmove</li>
<li>strcpy</li>
<li>strncpy</li>
<li>strcat</li>
<li>strncat</li>
<li>memcmp</li>
<li>strcmp</li>
<li>strncmp</li>
<li>memchr</li>
<li>strchr</li>
<li>strcspn</li>
<li>strpbrk</li>
<li>strrchr</li>
<li>strspn</li>
<li>strstr</li>
<li>memset</li>
<li>strlen</li>
</code></ul>
Portions of <code>&lt;cwchar&gt;</code>.
<ul>
<code><li>wcscpy</li>
<li>wcsncpy</li>
<li>wmemcpy</li>
<li>wmemmove</li>
<li>wcscat</li>
<li>wcsncat</li>
<li>wcscmp</li>
<li>wcsncmp</li>
<li>wmemcmp</li>
<li>wcschr</li>
<li>wcscspn</li>
<li>wcxpbrk</li>
<li>wcsrchr</li>
<li>wcsspn</li>
<li>wcsstr</li>
<li>wcstok</li>
<li>wmemchr</li>
<li>wcslen</li>
<li>wmemset</li>
</code></ul>
<p>
All of <code>&lt;array&gt;</code> except for <code>array::at</code>.
</p><p>
All of <code>&lt;iterator&gt;</code> except for the stream iterators and the insert iterators.
</p><p>
Most of <code>&lt;algorithm&gt;</code> and <code>&lt;numeric&gt;</code>.  The ExecutionPolicy overloads will not be included.  The following functions will be <b>omitted</b> due to the usage of temporary buffers:
</p>
<ul>
<code><li>stable_sort</li>
<li>stable_partition</li>
<li>inplace_merge</li>
</code></ul>
<p>
Portions of <code>&lt;random&gt;</code>.  The following portions will be included:
</p>
<ul>
<code>
<li>linear_congruential_engine</li>
<li>mersenne_twister_engine</li>
<li>subtract_with_carry_engine</li>
<li>discard_block_engine</li>
<li>independent_bits_engine</li>
<li>shuffle_order_engine</li>
<li>[rand.predef]</li>
<li>uniform_int_distribution</li>
</code></ul>
A small portion of <code>&lt;cmath&gt;</code> will be present.
<ul>
<code><li>abs(int)</li>
<li>abs(long int)</li>
<li>abs(long long int)</li>
</code></ul>
A portion of <code>&lt;cinttypes&gt;</code> will be present.
<ul>
<code><li>imaxabs</li>
<li>imaxdiv</li>
<li>abs(intmax_t)</li>
<li>div(intmax_t, intmax_t)</li>
</code></ul>
<h2>Notable omissions</h2>
<p>
<code>errno</code> is not included as it is global state.  In addition, errno is best implemented as a thread-local variable.
</p><p>
<code>error_code</code>, <code>error_condition</code>, and <code>error_category</code> all have <code>string</code> in the interface.
</p><p>
Many string functions (<code>strtol</code> and family) rely on <code>errno</code>.
</p><p>
<code>strtok</code> and <code>rand</code> aren't required to use thread-local storage, but good implementations do.  I don't want to encourage bad implementations.
</p><p>
<code>assert</code> is not included as it requires a stderror stream.
</p><p>
<code>&lt;cctype&gt;</code> and <code>&lt;cwctype&gt;</code> rely heavily on global locale data.
</p><p>
<code>default_delete</code> and <code>make_unique</code> are not included, although <code>unique_ptr</code> is included.  <code>default_delete</code> and <code>make_unique</code> have direct dependencies on heap management functionality.
</p><p>
<code>seed_seq</code> uses the heap.  Users can create their own classes satisfying the seed sequence requirements if they wish to use the Sseq constructors on the engine templates.
</p>
<h2>Potential removals</h2>
Here are some things that I am currently requiring, but could be convinced to remove.
<ul><li><code>&lt;cwchar&gt;</code></li></ul>
The <code>&lt;cwchar&gt;</code> functions are implementable for freestanding environments, but infrequently used for systems programming.  They do not exist in freestanding C11 implementations.
<ul><li><code>visit</code></li></ul>
<code>visit</code> only throws when the <code>variant</code> is valueless.  If exceptions are disabled, the <code>variant</code> will always have a value.  Since the standard doesn't acknowledge exceptions being disabled, we include the (hopefully) dead <code>bad_variant_access</code> class.
<ul><li><code>unique_ptr</code></li></ul>
<code>unique_ptr</code> is generally used for heap management, but is occasionally used as a makeshift RAII object for other resources.  In order to break the compile time dependency on <code>default_delete</code>, I add some implementation defined behavior for the freestanding implementation.  This may be too invasive for some committee members' tastes.  In the Jacksonville 2018 wg21 meeting, there was a strong interest in providing <code>unique_ptr</code>.
<ul><li>Partial classes</li></ul>
<code>array</code>, <code>bitset</code>, <code>optional</code>, <code>string_view</code>, and <code>variant</code> all have functions that throw.  These functions aren't critical to the use of the class.  The exceptions that <code>array</code>, <code>bitset</code>, and <code>string_view</code> throw are doubly bad, as those exceptions require <code>std::string</code>.  These headers and classes can be omitted if the committee strongly objects to marking a class partially freestanding.
<h2>Potential additions</h2>
Here are some things that I am not currently requiring, but could be convinced to add.
<ul><li><code>complex&lt;integer&gt;</code></li></ul>
I currently omit the <code>complex</code> class entirely, but in theory, the integer version of <code>complex</code> are fine.  I am unsure how many of the associated functions are implementable without floating point access though.  I do not believe that <code>complex</code> for integer types is a widely used class.
<ul><li>Floating point support</li></ul>
Perhaps we don't worry about library portability in all cases.  Just because kernel modes can't easily use floating point doesn't mean that we should deny floating point to the embedded space.  Do note that most of <code>&lt;cmath&gt;</code> has a dependency on <code>errno</code>.
<ul><li><code>errno</code> and string functions like <code>strtol</code></li></ul>
While <code>errno</code> is global data, it isn't much global data.  Thread safety is a concern for those platforms that have threading, but don't have thread-local storage.
<h1>Feature Test Macros</h1>
<p>
A freestanding implementation that provides support for this paper shall define the following feature test macro.
</p>
<table border="1">
    <thead><tr>
        <th>Name</th>
        <th>Value</th>
        <th>Header</th>
    </tr></thead>
    <tbody><tr>
        <td>__cpp_freestanding</td>
        <td><var>201803</var></td>
        <td><code>&lt;version&gt;<code></td>
    </tr></tbody>
</table>
<p>
The __cpp_freestanding macro is useful for detecting the absence of throwing facilities.  A user could conditionally use a hand-rolled implementation in freestanding mode or the standard implementation in hosted mode.
</p><p>
An implementation that has a hosted and a freestanding mode shall define all feature macros according to what is available in the current implementation mode.
</p>
<h1>Wording</h1>
<p>
Wording is based off of Working Draft, Standard for Programming Language C++, N4713.
</p>
Add a new subclause [freestanding.membership] after [objects.within.classes]:
<blockquote class="stdins">
<h4 ><a class='secnum' style='min-width:118pt'>20.4.2.5</a> Freestanding membership <a class='abbr_ref'>[freestanding.membership]</a></h4>
<div class='para'>
    <div class='marginalizedparent'><a class='marginalized'>1</a></div>
    <div class='sentence'>The freestanding implementation has several declarations and macro definitions that shall meet the same requirements as for a hosted implementation unless otherwise specified.</div>
    <div class='sentence'>In the associated header synopsis for such declarations and macro definitions, the items shall be followed with a comment that ends with <span class='textit'>freestanding</span>, as in:</div>
<pre class='codeblock'>
#define E2BIG <span class='textit'><span class='texttt'>see below</span></span> <span class='comment'>// <span class='textit'>freestanding</span></span>
</pre>
</div>
<div class='para'>
    <div class='marginalizedparent'><a class='marginalized'>2</a></div>
    <div class='sentence'>The freestanding implementation has several headers that shall meet the same requirements as for a hosted implementation unless otherwise specified.</div>
    <div class='sentence'>The synopsis for these headers shall start with a comment that ends with <span class='textit'>freestanding</span>, as in:</div>
<pre class='codeblock'>
<span class='comment'>// <span class='textit'>freestanding</span></span>
namespace std {
</pre>
    <div class='sentence'>Individual declarations and macro definitions in such a header shall not be followed with a comment that ends with <span class='textit'>freestanding</span>.</div>
</div>
<div class='para'>
    <div class='marginalizedparent'><a class='marginalized'>3</a></div>
    <div class='sentence'>Some classes and class templates are required to be partially implemented in a freestanding implementation.</div>
    <div class='sentence'>Such entities are permitted to be fully implemented in a freestanding implementation.</div>
    <div class='sentence'>In the associated header synopsis for such declarations, the declarations shall be followed with a comment that ends with <span class='textit'>freestanding, partial</span>, as in:</div>
<pre class='codeblock'>
  template&lt;class T&gt;
    class optional; <span class='comment'>// <span class='textit'>freestanding, partial</span></span>
</pre>
    <div class='sentence'>Some member functions in partially implemented entities are not required to be present in a freestanding implementation.</div>
    <div class='sentence'>In the associated class or class template synopsis for such member functions, the declarations shall be followed by a comment that ends with <span class='textit'>freestanding, omit</span>, as in:</div>
<pre class='codeblock'>
    constexpr const T&amp; value() const&amp;; <span class='comment'>// <span class='textit'>freestanding, omit</span></span>
</pre>
    <div class='sentence'>All declarations in the partially implemented class or class template that are not followed by a <span class='textit'>freestanding, omit</span> comment shall meet the same requirements as for a hosted implementation unless otherwise specified.</div>
</div>
<div class='para'>
    <div class='marginalizedparent'><a class='marginalized'>4</a></div>
    <div class='sentence'>Deduction guides for class templates that are implemented (partially or fully) in a freestanding implementation shall be implemented in a freestanding implementation.</div>
    <div class='sentence'>The containing namespace for each non-namespace declaration that is implemented (partially or fully) in a freestanding implementation shall be implemented in a freestanding implementation.</div>
</div>
</blockquote>

Rework Table 19 referenced from 20.5.1.3 [compliance]:
<del>
<div class='numberedTable'>Table 19 — C++ headers for freestanding implementations<br><table >
<tr class='rowsep'><td colspan='2' class='center'><div class='sentence'><b>Subclause</b></div></td><td class='left'><div class='sentence'><b>Header(s)</b></div></td></tr>
<tr class='capsep'>
    <td class='left'></td>
    <td class='left'></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;ciso646&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>21.2</div></td>
    <td class='left'><div class='sentence'>Types</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstddef&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>21.3</div></td>
    <td class='left'><div class='sentence'>Implementation properties</div></td>
    <td class='left'><div class='sentence'>
        <span class='texttt'>&lt;cfloat&gt;</span>
        <span class='texttt'>&lt;limits&gt;</span>
        <span class='texttt'>&lt;climits&gt;</span></div>
    </td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>21.4</div></td>
    <td class='left'><div class='sentence'>Integer types</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstdint&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>21.5</div></td>
    <td class='left'><div class='sentence'>Start and termination</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstdlib&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>21.6</div></td>
    <td class='left'><div class='sentence'>Dynamic memory management</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;new&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>21.7</div></td>
    <td class='left'><div class='sentence'>Type identification</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;typeinfo&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>21.8</div></td>
    <td class='left'><div class='sentence'>Exception handling</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;exception&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>21.9</div></td>
    <td class='left'><div class='sentence'>Initializer lists</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;initializer_&shy;list&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>21.11</div></td>
    <td class='left'><div class='sentence'>Other runtime support</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstdarg&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>23.15</div></td>
    <td class='left'><div class='sentence'>Type traits</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;type_&shy;traits&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>Clause 32</div></td>
    <td class='left'><div class='sentence'>Atomics</div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;atomic&gt;</span></div></td>
</tr>
<tr class='rowsep'>
    <td class='left'><div class='sentence'>D.4.2, D.4.3</div></td>
    <td class='left'><div class='sentence'>Deprecated headers</div></td>
    <td class='left'><div class='sentence'>
        <span class='texttt'>&lt;cstdalign&gt;</span>
        <span class='texttt'>&lt;cstdbool&gt;</span></div>
    </td>
</tr></table></div></div>
</del>
<ins>
<div class='numberedTable'>Table 19 — C++ headers for freestanding implementations<br><table >
<tr class='rowsep'>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;algorithm&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cmath&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;exception&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;ratio&gt;</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;array&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;compare&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;functional&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;string&gt;</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;atomic&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstdalign&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;initializer_list&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;string_view&gt;</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cerrno&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstdarg&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;iterator&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;system_error&gt;</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cfloat&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstdbool&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;limits&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;tuple&gt;</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;charconv&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstddef&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;memory&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;type_traits&gt;</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;chrono&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstdint&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;new&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;typeinfo&gt;</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cinttypes&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstdlib&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;numeric&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;utility&gt;</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;ciso646&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cstring&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;optional&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;variant&gt;</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;climits&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;cwchar&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;random&gt;</span></div></td>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;bitset&gt; TODO</span></div></td>
</tr>
<tr>
    <td class='left'><div class='sentence'><span class='texttt'>&lt;version&gt; TODO</span></div></td>
    <td class='left'></td>
    <td class='left'></td>
    <td class='left'></td>
</tr>
</table></div></ins>
Change in [compliance] (20.5.1.3) paragraph 3:
<blockquote class="std">
<div class='para'>
<del>
    <div class='sentence'>The supplied version of the header
    <span class='texttt'>&lt;cstdlib&gt;</span>
    shall declare at least the functions
    <span class='texttt'>abort</span>,
    <span class='texttt'>atexit</span>,
    <span class='texttt'>at_&shy;quick_&shy;exit</span>,
    <span class='texttt'>exit</span>,
    and
    <span class='texttt'>quick_&shy;exit</span> (21.5).</div>
    <div class='sentence'>The other headers listed in this table shall meet the same requirements as for a hosted implementation.</div>
</del>

<ins>
    <div class='sentence'>The supplied versions of the headers
    <span class='texttt'>&lt;atomic&gt;</span>,
    <span class='texttt'>&lt;cfloat&gt;</span>,
    <span class='texttt'>&lt;ciso646&gt;</span>,
    <span class='texttt'>&lt;climits&gt;</span>,
    <span class='texttt'>&lt;compare&gt;</span>,
    <span class='texttt'>&lt;cstdalign&gt;</span>,
    <span class='texttt'>&lt;cstdarg&gt;</span>,
    <span class='texttt'>&lt;cstdbool&gt;</span>,
    <span class='texttt'>&lt;cstddef&gt;</span>,
    <span class='texttt'>&lt;cstdint&gt;</span>,
    <span class='texttt'>&lt;exception&gt;</span>,
    <span class='texttt'>&lt;initializer_list&gt;</span>,
    <span class='texttt'>&lt;limits&gt;</span>,
    <span class='texttt'>&lt;new&gt;</span>,
    <span class='texttt'>&lt;ratio&gt;</span>,
    <span class='texttt'>&lt;tuple&gt;</span>,
    <span class='texttt'>&lt;type_traits&gt;</span>,
    <span class='texttt'>&lt;typeinfo&gt;</span>
    <span class='texttt'>&lt;utility&gt;</span>, and
    <span class='texttt'>&lt;version&gt;</span>
    shall meet the same requirements as for a hosted implementation.</div>
    <div class='sentence'>The other headers listed in this table shall meet the requirements for a freestanding implementation, as specified in the respective header synopsis.</div>
</ins>
</div>
</blockquote>

Change in [cstddef.syn] (21.2.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.2.1</a> Header <span class='texttt'>&lt;cstddef&gt;</span> synopsis <a class='abbr_ref'>[cstddef.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [cstdlib.syn] (21.2.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.2.2</a> Header <span class='texttt'>&lt;cstdlib&gt;</span> synopsis <a class='abbr_ref'>[cstdlib.syn]</a></h3>
<pre class='codeblock'>
namespace std {
  using size_t = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using div_t = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using ldiv_t = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using lldiv_t = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}

#define NULL <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EXIT_FAILURE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EXIT_SUCCESS <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define RAND_MAX <span class='textit'><span class='texttt'>see below</span></span>
#define MB_CUR_MAX <span class='textit'><span class='texttt'>see below</span></span>

namespace std {
  <span class='comment'>// Exposition-only function type aliases
</span>  extern "C" using <span class='textit'>c-atexit-handler</span> = void();                        <span class='comment'>// <span class='textit'>exposition only</span>
</span>  extern "C++" using <span class='textit'>atexit-handler</span> = void();                        <span class='comment'>// <span class='textit'>exposition only</span>
</span>  extern "C" using <span class='textit'>c-compare-pred</span> = int(const void*, const void*);   <span class='comment'>// <span class='textit'>exposition only</span>
</span>  extern "C++" using <span class='textit'>compare-pred</span> = int(const void*, const void*);   <span class='comment'>// <span class='textit'>exposition only</span>
</span>
  <span class='comment'>// 21.5, start and termination
</span>  [[noreturn]] void abort() noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  int atexit(<span class='textit'>c-atexit-handler</span>* func) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  int atexit(<span class='textit'>atexit-handler</span>* func) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  int at_quick_exit(<span class='textit'>c-atexit-handler</span>* func) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  int at_quick_exit(<span class='textit'>atexit-handler</span>* func) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  [[noreturn]] void exit(int status); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  [[noreturn]] void _Exit(int status) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  [[noreturn]] void quick_exit(int status) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  char* <span id='lib:getenv'><span class='tcode_in_codeblock'>getenv</span></span>(const char* name);
  int system(const char* string);

  <span class='comment'>// 23.10.12, C library memory allocation
</span>  void* aligned_alloc(size_t alignment, size_t size);
  void* calloc(size_t nmemb, size_t size);
  void free(void* ptr);
  void* malloc(size_t size);
  void* realloc(void* ptr, size_t size);

  double atof(const char* nptr);
  int atoi(const char* nptr);
  long int atol(const char* nptr);
  long long int atoll(const char* nptr);
  double strtod(const char* nptr, char** endptr);
  float strtof(const char* nptr, char** endptr);
  long double strtold(const char* nptr, char** endptr);
  long int strtol(const char* nptr, char** endptr, int base);
  long long int strtoll(const char* nptr, char** endptr, int base);
  unsigned long int strtoul(const char* nptr, char** endptr, int base);
  unsigned long long int strtoull(const char* nptr, char** endptr, int base);

  <span class='comment'>// 24.5.6, multibyte / wide string and character conversion functions
</span>  int mblen(const char* s, size_t n);
  int mbtowc(wchar_t* pwc, const char* s, size_t n);
  int wctomb(char* s, wchar_t wchar);
  size_t mbstowcs(wchar_t* pwcs, const char* s, size_t n);
  size_t wcstombs(char* s, const wchar_t* pwcs, size_t n);

  <span class='comment'>// 28.8, C standard library algorithms
</span>  void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
                <span class='textit'>c-compare-pred</span>* compar); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
                <span class='textit'>compare-pred</span>* compar); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  void qsort(void* base, size_t nmemb, size_t size, <span class='textit'>c-compare-pred</span>* compar); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  void qsort(void* base, size_t nmemb, size_t size, <span class='textit'>compare-pred</span>* compar); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.6.9, low-quality random number generation
</span>  int rand();
  void srand(unsigned int seed);

  <span class='comment'>// 29.9.2, absolute values
</span>  int abs(int j); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  long int abs(long int j); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  long long int abs(long long int j); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  float abs(float j);
  double abs(double j);
  long double abs(long double j);

  long int labs(long int j); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  long long int llabs(long long int j); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  div_t div(int numer, int denom); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  ldiv_t div(long int numer, long int denom);             <span class='comment'>// see 20.2<ins>, <span class='textit'>freestanding</span></ins>
</span>  lldiv_t div(long long int numer, long long int denom);  <span class='comment'>// see 20.2<ins>, <span class='textit'>freestanding</span></ins>
</span>  ldiv_t ldiv(long int numer, long int denom); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  lldiv_t lldiv(long long int numer, long long int denom); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}</pre>
</blockquote>

Change in [limits.syn] (21.3.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.3.2</a> Header <span class='texttt'>&lt;limits&gt;</span> synopsis <a class='abbr_ref'>[limits.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [climits.syn] (21.3.5):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.3.5</a> Header <span class='texttt'>&lt;climits&gt;</span> synopsis <a class='abbr_ref'>[climits.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define CHAR_BIT <span class='textit'><span class='texttt'>see below</span></span>
</pre>
</blockquote>

Change in [cfloat.syn] (21.3.6):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.3.6</a> Header <span class='texttt'>&lt;cfloat&gt;</span> synopsis <a class='abbr_ref'>[cfloat.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define FLT_ROUNDS <span class='textit'><span class='texttt'>see below</span></span>
</pre>
</blockquote>

Change in [cstdint.syn] (21.4.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.4.1</a> Header <span class='texttt'>&lt;cstdint&gt;</span> synopsis <a class='abbr_ref'>[cstdint.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [new.syn] (21.6.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.6.1</a> Header <span class='texttt'>&lt;new&gt;</span> synopsis <a class='abbr_ref'>[new.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [typeinfo.syn] (21.7.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.7.1</a> Header <span class='texttt'>&lt;typeinfo&gt;</span> synopsis <a class='abbr_ref'>[typeinfo.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [exception.syn] (21.8.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.8.1</a> Header <span class='texttt'>&lt;exception&gt;</span> synopsis <a class='abbr_ref'>[exception.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [initializer_list.syn] (21.9.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.9.1</a> Header <span class='texttt'>&lt;initializer_list&gt;</span> synopsis <a class='abbr_ref'>[initializer_list.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [cmp.syn] (21.10.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.10.1</a> Header <span class='texttt'>&lt;compare&gt;</span> synopsis <a class='abbr_ref'>[cmp.syn]</a></h3>
<div class='para'>
    <div class='marginalizedparent'><a class='marginalized'>1</a></div>
    <div class='sentence'>The header <span class='texttt'>&lt;compare&gt;</span> specifies types, objects, and functions for use primarily in connection with the three-way comparison operator (8.5.8).</div>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</div>
</blockquote>

Change in [cstdarg.syn] (21.11.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>21.11.1</a> Header <span class='texttt'>&lt;cstdarg&gt;</span> synopsis <a class='abbr_ref'>[cstdarg.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [cerrno.syn] (22.4.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>22.4.1</a> Header <span class='texttt'>&lt;cerrno&gt;</span> synopsis <a class='abbr_ref'>[cerrno.syn]</a></h3>
<pre class='codeblock'>
#define errno <span class='textit'><span class='texttt'>see below</span></span>

#define E2BIG <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EACCES <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EADDRINUSE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EADDRNOTAVAIL <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EAFNOSUPPORT <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EAGAIN <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EALREADY <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EBADF <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EBADMSG <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EBUSY <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ECANCELED <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ECHILD <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ECONNABORTED <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ECONNREFUSED <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ECONNRESET <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EDEADLK <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EDESTADDRREQ <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EDOM <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EEXIST <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EFAULT <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EFBIG <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EHOSTUNREACH <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EIDRM <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EILSEQ <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EINPROGRESS <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EINTR <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EINVAL <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EIO <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EISCONN <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EISDIR <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ELOOP <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EMFILE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EMLINK <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EMSGSIZE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENAMETOOLONG <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENETDOWN <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENETRESET <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENETUNREACH <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENFILE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOBUFS <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENODATA <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENODEV <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOENT <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOEXEC <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOLCK <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOLINK <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOMEM <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOMSG <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOPROTOOPT <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOSPC <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOSR <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOSTR <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOSYS <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOTCONN <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOTDIR <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOTEMPTY <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOTRECOVERABLE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOTSOCK <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOTSUP <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENOTTY <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ENXIO <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EOPNOTSUPP <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EOVERFLOW <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EOWNERDEAD <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EPERM <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EPIPE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EPROTO <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EPROTONOSUPPORT <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EPROTOTYPE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ERANGE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EROFS <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ESPIPE <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ESRCH <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ETIME <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ETIMEDOUT <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define ETXTBSY <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EWOULDBLOCK <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define EXDEV <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
</pre>

<div class='para'>
    <div class='marginalizedparent'><a class='marginalized'>1</a></div>
    <div class='sentence'>The meaning of the macros in this header is defined by the POSIX standard.</div>
    <div style='height:0.6em;display:block'></div>
    <div class='sentence'><span class='textsc'>See also:</span> ISO C 7.5</div>
</div>
</blockquote>

Change in [system_error.syn] (22.5.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>22.5.1</a> Header <span class='texttt'>&lt;system_&shy;error&gt;</span> synopsis <a class='abbr_ref'>[system_error.syn]</a></h3>
<div  class='sentence'>
<pre class='codeblock'>
namespace std {
  class error_category;
  const error_category&amp; generic_category() noexcept;
  const error_category&amp; system_category() noexcept;

  class error_code;
  class error_condition;
  class system_error;

  template&lt;class T&gt;
    struct is_error_code_enum : public false_type {};

  template&lt;class T&gt;
    struct is_error_condition_enum : public false_type {};

  enum class errc { <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    address_family_not_supported,       <span class='comment'>// <span class='tcode_in_codeblock'>EAFNOSUPPORT</span>
</span>    address_in_use,                     <span class='comment'>// <span class='tcode_in_codeblock'>EADDRINUSE</span>
</span>    address_not_available,              <span class='comment'>// <span class='tcode_in_codeblock'>EADDRNOTAVAIL</span>
</span></pre>
</div>
</blockquote>

Change in [utility.syn] (23.2.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.2.1</a> Header <span class='texttt'>&lt;utility&gt;</span> synopsis <a class='abbr_ref'>[utility.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [tuple.syn] (23.5.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.5.2</a> Header <span class='texttt'>&lt;tuple&gt;</span> synopsis <a class='abbr_ref'>[tuple.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [optional.syn] (23.6.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.6.2</a> Header <span class='texttt'>&lt;optional&gt;</span> synopsis <a class='abbr_ref'>[optional.syn]</a></h3>
<pre class='codeblock'>
namespace std {
  <span class='comment'>// 23.6.3, class template <span class='tcode_in_codeblock'>optional</span>
</span>  template&lt;class T&gt;
    class optional; <ins><span class='comment'>// <span class='textit'>freestanding, partial</span></span></ins>

  <span class='comment'>// 23.6.4, no-value state indicator
</span>  struct nullopt_t{<span class='textit'><span class='texttt'>see below</span></span>}; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  inline constexpr nullopt_t nullopt(<span class='textit'><span class='texttt'>unspecified</span></span>); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.6.5, class <span class='tcode_in_codeblock'>bad_&shy;optional_&shy;access</span>
</span>  class bad_optional_access;

  <span class='comment'>// 23.6.6, relational operators
</span>  template&lt;class T, class U&gt;
  constexpr bool operator==(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt;
  constexpr bool operator!=(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt;
  constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt;
  constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt;
  constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt;
  constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.6.7, comparison with <span class='tcode_in_codeblock'>nullopt</span>
</span>  template&lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, nullopt_t) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.6.8, comparison with <span class='tcode_in_codeblock'>T</span>
</span>  template&lt;class T, class U&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, const U&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator==(const T&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, const U&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator!=(const T&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const U&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator&lt;(const T&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const U&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator&lt;=(const T&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const U&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator&gt;(const T&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const U&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U&gt; constexpr bool operator&gt;=(const T&amp;, const optional&lt;U&gt;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.6.9, specialized algorithms
</span>  template&lt;class T&gt;
    void swap(optional&lt;T&gt;&amp;, optional&lt;T&gt;&amp;) noexcept(<span class='textit'><span class='texttt'>see below</span></span>); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class T&gt;
    constexpr optional&lt;<span class='textit'><span class='texttt'>see below</span></span>&gt; make_optional(T&amp;&amp;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class... Args&gt;
    constexpr optional&lt;T&gt; make_optional(Args&amp;&amp;... args); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class U, class... Args&gt;
    constexpr optional&lt;T&gt; make_optional(initializer_list&lt;U&gt; il, Args&amp;&amp;... args); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.6.10, hash support
</span>  template&lt;class T&gt; struct hash; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; struct hash&lt;optional&lt;T&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}</pre>
</blockquote>

Change in [optional.optional] (23.6.3)
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.6.3</a> Class template <span class='texttt'>optional</span> <a class='abbr_ref'>[optional.optional]</a></h3>
<pre class='codeblock'>
template&lt;class T&gt;
  class optional {
  public:
    using value_type = T;

    <span class='comment'>// 23.6.3.1, constructors
</span>    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    constexpr optional(const optional&amp;);
    constexpr optional(optional&amp;&amp;) noexcept(<span class='textit'><span class='texttt'>see below</span></span>);
    template&lt;class... Args&gt;
      constexpr explicit optional(in_place_t, Args&amp;&amp;...);
    template&lt;class U, class... Args&gt;
      constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    template&lt;class U = T&gt;
      <span class='textit'><span class='texttt'>EXPLICIT</span></span> constexpr optional(U&amp;&amp;);
    template&lt;class U&gt;
      <span class='textit'><span class='texttt'>EXPLICIT</span></span> optional(const optional&lt;U&gt;&amp;);
    template&lt;class U&gt;
      <span class='textit'><span class='texttt'>EXPLICIT</span></span> optional(optional&lt;U&gt;&amp;&amp;);

    <span class='comment'>// 23.6.3.2, destructor
</span>    ~optional();

    <span class='comment'>// 23.6.3.3, assignment
</span>    optional&amp; operator=(nullopt_t) noexcept;
    optional&amp; operator=(const optional&amp;);
    optional&amp; operator=(optional&amp;&amp;) noexcept(<span class='textit'><span class='texttt'>see below</span></span>);
    template&lt;class U = T&gt; optional&amp; operator=(U&amp;&amp;);
    template&lt;class U&gt; optional&amp; operator=(const optional&lt;U&gt;&amp;);
    template&lt;class U&gt; optional&amp; operator=(optional&lt;U&gt;&amp;&amp;);
    template&lt;class... Args&gt; T&amp; emplace(Args&amp;&amp;...);
    template&lt;class U, class... Args&gt; T&amp; emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);

    <span class='comment'>// 23.6.3.4, swap
</span>    void swap(optional&amp;) noexcept(<span class='textit'><span class='texttt'>see below</span></span>);

    <span class='comment'>// 23.6.3.5, observers
</span>    constexpr const T* operator-&gt;() const;
    constexpr T* operator-&gt;();
    constexpr const T&amp; operator*() const&amp;;
    constexpr T&amp; operator*() &amp;;
    constexpr T&amp;&amp; operator*() &amp;&amp;;
    constexpr const T&amp;&amp; operator*() const&amp;&amp;;
    constexpr explicit operator bool() const noexcept;
    constexpr bool has_value() const noexcept;
    constexpr const T&amp; value() const&amp;; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
    constexpr T&amp; value() &amp;; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
    constexpr T&amp;&amp; value() &amp;&amp;; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
    constexpr const T&amp;&amp; value() const&amp;&amp;; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
    template&lt;class U&gt; constexpr T value_or(U&amp;&amp;) const&amp;;
    template&lt;class U&gt; constexpr T value_or(U&amp;&amp;) &amp;&amp;;

    <span class='comment'>// 23.6.3.6, modifiers
</span>    void reset() noexcept;

  private:
    T *val; <span class='comment'>// <span class='textit'>exposition only</span>
</span>  };

template&lt;class T&gt; optional(T) -&gt; optional&lt;T&gt;;
</pre>
</blockquote>

Change in [variant.syn] (23.7.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.7.2</a> Header <span class='texttt'>&lt;variant&gt;</span> synopsis <a class='abbr_ref'>[variant.syn]</a></h3>
<pre class='codeblock'>
namespace std {
  <span class='comment'>// 23.7.3, class template <span class='tcode_in_codeblock'>variant</span>
</span>  template&lt;class... Types&gt;
    class variant; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.7.4, variant helper classes
</span>  template&lt;class T&gt; struct variant_size;                   <span class='comment'>// not defined<ins>, <span class='textit'>freestanding</span></ins>
</span>  template&lt;class T&gt; struct variant_size&lt;const T&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; struct variant_size&lt;volatile T&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; struct variant_size&lt;const volatile T&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt;
    inline constexpr size_t variant_size_v = variant_size&lt;T&gt;::value; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class... Types&gt;
    struct variant_size&lt;variant&lt;Types...&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;size_t I, class T&gt; struct variant_alternative;  <span class='comment'>// not defined<ins>, <span class='textit'>freestanding</span></ins>
</span>  template&lt;size_t I, class T&gt; struct variant_alternative&lt;I, const T&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class T&gt; struct variant_alternative&lt;I, volatile T&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class T&gt; struct variant_alternative&lt;I, const volatile T&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class T&gt;
    using variant_alternative_t = typename variant_alternative&lt;I, T&gt;::type; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;size_t I, class... Types&gt;
    struct variant_alternative&lt;I, variant&lt;Types...&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  inline constexpr size_t variant_npos = -1; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.7.5, value access
</span>  template&lt;class T, class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr bool holds_alternative(const variant&lt;Types...&gt;&amp;) noexcept; 

  template&lt;size_t I, class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp; get(variant&lt;Types...&gt;&amp;);
  template&lt;size_t I, class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;&amp; get(variant&lt;Types...&gt;&amp;&amp;);
  template&lt;size_t I, class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr const variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp; get(const variant&lt;Types...&gt;&amp;);
  template&lt;size_t I, class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr const variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;&amp; get(const variant&lt;Types...&gt;&amp;&amp;);

  template&lt;class T, class... Types&gt;
    constexpr T&amp; get(variant&lt;Types...&gt;&amp;);
  template&lt;class T, class... Types&gt;
    constexpr T&amp;&amp; get(variant&lt;Types...&gt;&amp;&amp;);
  template&lt;class T, class... Types&gt;
    constexpr const T&amp; get(const variant&lt;Types...&gt;&amp;);
  template&lt;class T, class... Types&gt;
    constexpr const T&amp;&amp; get(const variant&lt;Types...&gt;&amp;&amp;);

  template&lt;size_t I, class... Types&gt;
    constexpr add_pointer_t&lt;variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&gt;
      get_if(variant&lt;Types...&gt;*) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class... Types&gt;
    constexpr add_pointer_t&lt;const variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&gt;
      get_if(const variant&lt;Types...&gt;*) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class T, class... Types&gt;
    constexpr add_pointer_t&lt;T&gt;
      get_if(variant&lt;Types...&gt;*) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class... Types&gt;
    constexpr add_pointer_t&lt;const T&gt;
      get_if(const variant&lt;Types...&gt;*) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.7.6, relational operators
</span>  template&lt;class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr bool operator==(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);
  template&lt;class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr bool operator!=(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);
  template&lt;class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr bool operator&lt;(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);
  template&lt;class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr bool operator&gt;(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);
  template&lt;class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr bool operator&lt;=(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);
  template&lt;class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr bool operator&gt;=(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);

  <span class='comment'>// 23.7.7, visitation
</span>  template&lt;class Visitor, class... Variants&gt;
    constexpr <span class='textit'><span class='texttt'>see below</span></span> visit(Visitor&amp;&amp;, Variants&amp;&amp;...); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.7.8, class <span class='tcode_in_codeblock'>monostate</span>
</span>  struct monostate; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.7.9, <span class='tcode_in_codeblock'>monostate</span> relational operators
</span>  constexpr bool operator&lt;(monostate, monostate) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  constexpr bool operator&gt;(monostate, monostate) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  constexpr bool operator&lt;=(monostate, monostate) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  constexpr bool operator&gt;=(monostate, monostate) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  constexpr bool operator==(monostate, monostate) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  constexpr bool operator!=(monostate, monostate) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.7.10, specialized algorithms
</span>  template&lt;class... Types&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    void swap(variant&lt;Types...&gt;&amp;, variant&lt;Types...&gt;&amp;) noexcept(<span class='textit'><span class='texttt'>see below</span></span>);

  <span class='comment'>// 23.7.11, class <span class='tcode_in_codeblock'>bad_&shy;variant_&shy;access</span>
</span>  class bad_variant_access; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.7.12, hash support
</span>  template&lt;class T&gt; struct hash; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class... Types&gt; struct hash&lt;variant&lt;Types...&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct hash&lt;monostate&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}
</pre></blockquote>

Change in [bitset.syn] (23.9.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.9.1</a> Header <span class='texttt'>&lt;bitset&gt;</span> synopsis <a class='abbr_ref'>[bitset.syn]</a></h3>
<pre class='codeblock'>
#include &lt;string&gt;
#include &lt;iosfwd&gt;   <span class='comment'>// for <span class='tcode_in_codeblock'>istream</span>, <span class='tcode_in_codeblock'>ostream</span>, see [iosfwd.syn]
</span>
namespace std {
  template&lt;size_t N&gt; class bitset; <ins><span class='comment'>// <span class='textit'>freestanding, partial</span></span></ins>

  <span class='comment'>// [bitset.operators], bitset operators
</span>  template&lt;size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bitset&lt;N&gt; operator&amp;(const bitset&lt;N&gt;&amp;, const bitset&lt;N&gt;&amp;) noexcept;
  template&lt;size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bitset&lt;N&gt; operator|(const bitset&lt;N&gt;&amp;, const bitset&lt;N&gt;&amp;) noexcept;
  template&lt;size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bitset&lt;N&gt; operator^(const bitset&lt;N&gt;&amp;, const bitset&lt;N&gt;&amp;) noexcept;
  template&lt;class charT, class traits, size_t N&gt;
    basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, bitset&lt;N&gt;&amp; x);
  template&lt;class charT, class traits, size_t N&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const bitset&lt;N&gt;&amp; x);
}</pre></blockquote>

Change in [template.bitset] (23.9.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.9.2</a> Class template <span class='texttt'>bitset</span> <a class='abbr_ref'>[template.bitset]</a></h3><pre class='codeblock'>
namespace std {
  template&lt;size_t N&gt; class bitset {
  public:
    <span class='comment'>// bit reference
</span>    class reference {
      friend class bitset;
      reference() noexcept;

    public:
      ~reference() noexcept;
      reference&amp; operator=(bool x) noexcept;            <span class='comment'>// for <span class='tcode_in_codeblock'>b[i] = x;</span>
</span>      reference&amp; operator=(const reference&amp;) noexcept;  <span class='comment'>// for <span class='tcode_in_codeblock'>b[i] = b[j];</span>
</span>      bool operator~() const noexcept;                  <span class='comment'>// flips the bit
</span>      operator bool() const noexcept;                   <span class='comment'>// for <span class='tcode_in_codeblock'>x = b[i];</span>
</span>      reference&amp; flip() noexcept;                       <span class='comment'>// for <span class='tcode_in_codeblock'>b[i].flip();</span>
</span>    };

    <span class='comment'>// [bitset.cons], constructors
</span>    constexpr bitset() noexcept;
    constexpr bitset(unsigned long long val) noexcept;
    template&lt;class charT, class traits, class Allocator&gt;
      explicit bitset(
        const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
        typename basic_string&lt;charT, traits, Allocator&gt;::size_type pos = 0,
        typename basic_string&lt;charT, traits, Allocator&gt;::size_type n
          = basic_string&lt;charT, traits, Allocator&gt;::npos,
        charT zero = charT('0'),
        charT one = charT('1')); <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
    template&lt;class charT&gt;
      explicit bitset(
        const charT* str,
        typename basic_string&lt;charT&gt;::size_type n = basic_string&lt;charT&gt;::npos,
        charT zero = charT('0'),
        charT one = charT('1')); <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>

    <span class='comment'>// [bitset.members], bitset operations
</span>    bitset&lt;N&gt;&amp; operator&amp;=(const bitset&lt;N&gt;&amp; rhs) noexcept;
    bitset&lt;N&gt;&amp; operator|=(const bitset&lt;N&gt;&amp; rhs) noexcept;
    bitset&lt;N&gt;&amp; operator^=(const bitset&lt;N&gt;&amp; rhs) noexcept;
    bitset&lt;N&gt;&amp; operator&lt;&lt;=(size_t pos) noexcept;
    bitset&lt;N&gt;&amp; operator&gt;&gt;=(size_t pos) noexcept;
    bitset&lt;N&gt;&amp; set() noexcept;
    bitset&lt;N&gt;&amp; set(size_t pos, bool val = true); <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
    bitset&lt;N&gt;&amp; reset() noexcept;
    bitset&lt;N&gt;&amp; reset(size_t pos); <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
    bitset&lt;N&gt;  operator~() const noexcept;
    bitset&lt;N&gt;&amp; flip() noexcept;
    bitset&lt;N&gt;&amp; flip(size_t pos); <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>

    <span class='comment'>// element access
</span>    constexpr bool operator[](size_t pos) const;        <span class='comment'>// for <span class='tcode_in_codeblock'>b[i];</span>
</span>    reference operator[](size_t pos);                   <span class='comment'>// for <span class='tcode_in_codeblock'>b[i];</span>
</span>
    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template&lt;class charT = char,
              class traits = char_traits&lt;charT&gt;,
              class Allocator = allocator&lt;charT&gt;&gt;
      basic_string&lt;charT, traits, Allocator&gt;
        to_string(charT zero = charT('0'), charT one = charT('1')) const; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>

    size_t count() const noexcept;
    constexpr size_t size() const noexcept;
    bool operator==(const bitset&lt;N&gt;&amp; rhs) const noexcept;
    bool operator!=(const bitset&lt;N&gt;&amp; rhs) const noexcept;
    bool test(size_t pos) const;
    bool all() const noexcept;
    bool any() const noexcept;
    bool none() const noexcept;
    bitset&lt;N&gt; operator&lt;&lt;(size_t pos) const noexcept;
    bitset&lt;N&gt; operator&gt;&gt;(size_t pos) const noexcept;
  };

  <span class='comment'>// [bitset.hash], hash support
</span>  template&lt;class T&gt; struct hash;
  template&lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt;&gt;;
}</pre></blockquote>

Change in [memory.syn] (23.10.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.10.2</a> Header <span class='texttt'>&lt;memory&gt;</span> synopsis <a class='abbr_ref'>[memory.syn]</a></h3>
<div class='para' >
    <div class='marginalizedparent'><a class='marginalized'>1</a></div>
    <div  class='sentence'>The header <span class='texttt'>&lt;memory&gt;</span> defines several types and function templates that
describe properties of pointers and pointer-like types, manage memory
for containers and other template types, destroy objects, and
construct multiple objects in
uninitialized memory
buffers (23.10.3–23.10.11).</div>
<div  class='sentence'>The header also defines the templates
<span class='texttt'>unique_&shy;ptr</span>, <span class='texttt'>shared_&shy;ptr</span>, <span class='texttt'>weak_&shy;ptr</span>, and various function
templates that operate on objects of these types (23.11).</div>
<pre class='codeblock'>
namespace std {
  <span class='comment'>// 23.10.3, pointer traits
</span>  template&lt;class Ptr&gt; struct pointer_traits; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; struct pointer_traits&lt;T*&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.10.4, pointer conversion
</span>  template&lt;class Ptr&gt;
    auto to_address(const Ptr&amp; p) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt;
    constexpr T* to_address(T* p) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.10.5, pointer safety
</span>  enum class pointer_safety { relaxed, preferred, strict };
  void declare_reachable(void* p);
  template&lt;class T&gt;
    T* undeclare_reachable(T* p);
  void declare_no_pointers(char* p, size_t n);
  void undeclare_no_pointers(char* p, size_t n);
  pointer_safety get_pointer_safety() noexcept;

  <span class='comment'>// 23.10.6, pointer alignment function
</span>  void* align(size_t alignment, size_t size, void*&amp; ptr, size_t&amp; space); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.10.7, allocator argument tag
</span>  struct allocator_arg_t { explicit allocator_arg_t() = default; }; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  inline constexpr allocator_arg_t allocator_arg{}; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.10.8, <span class='tcode_in_codeblock'>uses_&shy;allocator</span>
</span>  template&lt;class T, class Alloc&gt; struct uses_allocator; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.10.9, allocator traits
</span>  template&lt;class Alloc&gt; struct allocator_traits; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.10.10, the default allocator
</span>  template&lt;class T&gt; class allocator;
  template&lt;class T, class U&gt;
    bool operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;

  <span class='comment'>// 23.10.11, specialized algorithms
</span>  template&lt;class T&gt;
    constexpr T* addressof(T&amp; r) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt;
    const T* addressof(const T&amp;&amp;) = delete; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator&gt;
    void uninitialized_default_construct(ForwardIterator first, ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    void uninitialized_default_construct(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                         ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Size&gt;
    ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size&gt;
    ForwardIterator uninitialized_default_construct_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                                      ForwardIterator first, Size n);
  template&lt;class ForwardIterator&gt;
    void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);  <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    void uninitialized_value_construct(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                       ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Size&gt;
    ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size&gt;
    ForwardIterator uninitialized_value_construct_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                                    ForwardIterator first, Size n);
  template&lt;class InputIterator, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                       ForwardIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class InputIterator, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template&lt;class InputIterator, class Size, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                         ForwardIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                         InputIterator first, Size n,
                                         ForwardIterator result);
  template&lt;class InputIterator, class ForwardIterator&gt;
    ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                       ForwardIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class InputIterator, class ForwardIterator&gt;
    ForwardIterator uninitialized_move(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template&lt;class InputIterator, class Size, class ForwardIterator&gt;
    pair&lt;InputIterator, ForwardIterator&gt; uninitialized_move_n(InputIterator first, Size n,
                                                              ForwardIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator&gt;
    pair&lt;InputIterator, ForwardIterator&gt; uninitialized_move_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                                              InputIterator first, Size n,
                                                              ForwardIterator result);
  template&lt;class ForwardIterator, class T&gt;
    void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T&amp; x); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    void uninitialized_fill(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                            ForwardIterator first, ForwardIterator last, const T&amp; x);
  template&lt;class ForwardIterator, class Size, class T&gt;
    ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class T&gt;
    ForwardIterator uninitialized_fill_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                         ForwardIterator first, Size n, const T&amp; x);
  template&lt;class T&gt;
    void destroy_at(T* location); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator&gt;
    void destroy(ForwardIterator first, ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    void destroy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                 ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Size&gt;
    ForwardIterator destroy_n(ForwardIterator first, Size n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size&gt;
    ForwardIterator destroy_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                              ForwardIterator first, Size n);

  <span class='comment'>// 23.11.1, class template <span class='tcode_in_codeblock'>unique_&shy;ptr</span>
</span>  template&lt;class T&gt; struct default_delete;
  template&lt;class T&gt; struct default_delete&lt;T[]&gt;;
  template&lt;class T, class D = <ins><span class='textit'><span class='texttt'>see below</span></span></ins><del>default_delete&lt;T&gt;</del>&gt; class unique_ptr; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class T, class... Args&gt; unique_ptr&lt;T&gt;
    make_unique(Args&amp;&amp;... args);                                                <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is not array
</span>  template&lt;class T&gt; unique_ptr&lt;T&gt;
    make_unique(size_t n);                                                      <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[]</span>
</span>  template&lt;class T, class... Args&gt;
    <span class='textit'><span class='texttt'>unspecified</span></span> make_unique(Args&amp;&amp;...) = delete;                                <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[N]</span>
</span>
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;

  template&lt;class T1, class D1, class T2, class D2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);

  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);

  template&lt;class E, class T, class Y, class D&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;E, T&gt;&amp; os, const unique_ptr&lt;Y, D&gt;&amp; p);

  <span class='comment'>// 23.11.2, class <span class='tcode_in_codeblock'>bad_&shy;weak_&shy;ptr</span>
</span>  class bad_weak_ptr;

  <span class='comment'>// 23.11.3, class template <span class='tcode_in_codeblock'>shared_&shy;ptr</span>
</span>  template&lt;class T&gt; class shared_ptr;

  <span class='comment'>// 23.11.3.6, <span class='tcode_in_codeblock'>shared_&shy;ptr</span> creation
</span>  template&lt;class T, class... Args&gt;
    shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);                                  <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is not array
</span>  template&lt;class T, class A, class... Args&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);                  <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is not array
</span>
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared(size_t N);                                        <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[]</span>
</span>  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, size_t N);                        <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[]</span>
</span>
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared();                                                <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[N]</span>
</span>  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a);                                  <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[N]</span>
</span>
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared(size_t N, const remove_extent_t&lt;T&gt;&amp; u);           <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[]</span>
</span>  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, size_t N,
                                  const remove_extent_t&lt;T&gt;&amp; u);                 <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[]</span>
</span>
  template&lt;class T&gt; shared_ptr&lt;T&gt;
    make_shared(const remove_extent_t&lt;T&gt;&amp; u);                                   <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[N]</span>
</span>  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, const remove_extent_t&lt;T&gt;&amp; u);     <span class='comment'>// <span class='tcode_in_codeblock'>T</span> is <span class='tcode_in_codeblock'>U[N]</span>
</span>
  <span class='comment'>// 23.11.3.7, <span class='tcode_in_codeblock'>shared_&shy;ptr</span> comparisons
</span>  template&lt;class T, class U&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;

  template&lt;class T&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;

  <span class='comment'>// 23.11.3.8, <span class='tcode_in_codeblock'>shared_&shy;ptr</span> specialized algorithms
</span>  template&lt;class T&gt;
    void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// 23.11.3.9, <span class='tcode_in_codeblock'>shared_&shy;ptr</span> casts
</span>  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; reinterpret_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;

  <span class='comment'>// 23.11.3.10, <span class='tcode_in_codeblock'>shared_&shy;ptr</span> <span class='tcode_in_codeblock'>get_&shy;deleter</span>
</span>  template&lt;class D, class T&gt;
    D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;

  <span class='comment'>// 23.11.3.11, <span class='tcode_in_codeblock'>shared_&shy;ptr</span> I/O
</span>  template&lt;class E, class T, class Y&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;E, T&gt;&amp; os, const shared_ptr&lt;Y&gt;&amp; p);

  <span class='comment'>// 23.11.4, class template <span class='tcode_in_codeblock'>weak_&shy;ptr</span>
</span>  template&lt;class T&gt; class weak_ptr;

  <span class='comment'>// 23.11.4.6, <span class='tcode_in_codeblock'>weak_&shy;ptr</span> specialized algorithms
</span>  template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// 23.11.5, class template <span class='tcode_in_codeblock'>owner_&shy;less</span>
</span>  template&lt;class T = void&gt; struct owner_less;

  <span class='comment'>// 23.11.6, class template <span class='tcode_in_codeblock'>enable_&shy;shared_&shy;from_&shy;this</span>
</span>  template&lt;class T&gt; class enable_shared_from_this;

  <span class='comment'>// 23.11.7, hash support
</span>  template&lt;class T&gt; struct hash; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt;&gt;;

  <span class='comment'>// 23.11.8, atomic smart pointers
</span>  template&lt;class T&gt; struct atomic&lt;shared_ptr&lt;T&gt;&gt;;
  template&lt;class T&gt; struct atomic&lt;weak_ptr&lt;T&gt;&gt;;

  <span class='comment'>// 23.10.8.1, <span class='tcode_in_codeblock'>uses_&shy;allocator</span>
</span>  template&lt;class T, class Alloc&gt;
    inline constexpr bool uses_allocator_v = uses_allocator&lt;T, Alloc&gt;::value; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}</pre></div>
</blockquote>

Change in [unique.ptr.dltr.general] (21.11.1.1.1) paragraph 1:
<blockquote class="std">
<div id='1.sentence-1' class='sentence'>The class template <span class='texttt'>default_&shy;delete</span> serves as the default deleter (destruction policy)
for the class template <span class='texttt'>unique_&shy;ptr</span> <ins>for hosted implementations</ins>.</div>
</blockquote>

Change in [unique.ptr.single] (21.11.1.2):
<blockquote class="std">
<h4 ><a class='secnum' style='min-width:118pt'>23.11.1.2</a> <span class='texttt'>unique_&shy;ptr</span> for single objects <a class='abbr_ref'>[unique.ptr.single]</a></h4><pre class='codeblock'>
namespace std {
  template&lt;class T, class D = <ins><span class='textit'><span class='texttt'>see below</span></span></ins><del>default_delete&lt;T&gt;</del>&gt; class unique_ptr {
  public:
    using pointer      = <span class='textit'><span class='texttt'>see below</span></span>;
    using element_type = T;
    using deleter_type = D;

    <span class='comment'>// [unique.ptr.single.ctor], constructors
</span>    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, <span class='textit'><span class='texttt'>see below</span></span> d1) noexcept;
    unique_ptr(pointer p, <span class='textit'><span class='texttt'>see below</span></span> d2) noexcept;
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;

    <span class='comment'>// [unique.ptr.single.dtor], destructor
</span>    ~unique_ptr();

    <span class='comment'>// [unique.ptr.single.asgn], assignment
</span>    unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    unique_ptr&amp; operator=(nullptr_t) noexcept;

    <span class='comment'>// [unique.ptr.single.observers], observers
</span>    add_lvalue_reference_t&lt;T&gt; operator*() const;
    pointer operator-&gt;() const noexcept;
    pointer get() const noexcept;
    deleter_type&amp; get_deleter() noexcept;
    const deleter_type&amp; get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    <span class='comment'>// [unique.ptr.single.modifiers], modifiers
</span>    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr&amp; u) noexcept;

    <span class='comment'>// disable copy from lvalue
</span>    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
  };
}</pre>
<div class='para' id='1'><div class='marginalizedparent'><a class='marginalized'>1</a></div>
<div id='1.sentence-1' class='sentence'>The default type for the template parameter <span class='texttt'>D</span> is
<span class='texttt'>default_&shy;delete</span> <ins>for hosted implementations</ins>.</div>

<ins>
<div id='1.sentence-x1' class='sentence'>The default type for the template parameter <span class='texttt'>D</span> is implementation defined for freestanding implementations.</div>
<div id='1.sentence-x2' class='sentence'>If the type of the template argument <span class='texttt'>D</span> matches the default type for the template parameter <span class='texttt'>D</span>, and that type is not <span class='texttt'>default_&shy;delete</span>, then the program is ill-formed.</div>
<div id='1.sentence-x3' class='sentence'>[ Footnote: The intent is to require freestanding users to provide a deleter argument, rather than rely on <span class='texttt'>default_&shy;delete</span>, as <span class='texttt'>default_&shy;delete</span> may not be present in a freestanding implementation. ]</div>
</ins>

<div id='1.sentence-2' class='sentence'>A client-supplied template argument
<span class='texttt'>D</span> shall be a
function object type,
lvalue reference to function, or
lvalue reference to function object type
for which, given
a value <span class='texttt'>d</span> of type <span class='texttt'>D</span> and a value
<span class='texttt'>ptr</span> of type <span class='texttt'>unique_&shy;ptr&lt;T, D&gt;&#x200b;::&#x200b;pointer</span>, the expression
<span class='texttt'>d(ptr)</span> is valid and has the effect of disposing of the
pointer as appropriate for that deleter.</div>
</div>
</blockquote>

Change in [functional.syn] (23.14.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.14.1</a> Header <span class='texttt'>&lt;functional&gt;</span> synopsis <a class='abbr_ref'>[functional.syn]</a></h3>
<pre class='codeblock'>
namespace std {
  <span class='comment'>// 23.14.4, invoke
</span>  template&lt;class F, class... Args&gt;
    invoke_result_t&lt;F, Args...&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args)
      noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.14.5, <span class='tcode_in_codeblock'>reference_&shy;wrapper</span>
</span>  template&lt;class T&gt; class reference_wrapper; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class T&gt; reference_wrapper&lt;T&gt; ref(T&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; reference_wrapper&lt;const T&gt; cref(const T&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; void ref(const T&amp;&amp;) = delete; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; void cref(const T&amp;&amp;) = delete; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class T&gt; reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.14.6, arithmetic operations
</span>  template&lt;class T = void&gt; struct plus; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct minus; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct multiplies; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct divides; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct modulus; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct negate; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct plus&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct minus&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct multiplies&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct divides&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct modulus&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct negate&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.14.7, comparisons
</span>  template&lt;class T = void&gt; struct equal_to; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct not_equal_to; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct greater; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct less; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct greater_equal; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct less_equal; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct equal_to&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct not_equal_to&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct greater&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct less&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct greater_equal&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct less_equal&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.14.8, logical operations
</span>  template&lt;class T = void&gt; struct logical_and; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct logical_or; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct logical_not; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct logical_and&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct logical_or&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct logical_not&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.14.9, bitwise operations
</span>  template&lt;class T = void&gt; struct bit_and; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct bit_or; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct bit_xor; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T = void&gt; struct bit_not; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct bit_and&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct bit_or&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct bit_xor&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct bit_not&lt;void&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.14.10, function template <span class='tcode_in_codeblock'>not_&shy;fn</span>
</span>  template&lt;class F&gt; <span class='textit'><span class='texttt'>unspecified</span></span> not_fn(F&amp;&amp; f); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.14.11, bind
</span>  template&lt;class T&gt; struct is_bind_expression; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; struct is_placeholder; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class F, class... BoundArgs&gt;
    <span class='textit'><span class='texttt'>unspecified</span></span> bind(F&amp;&amp;, BoundArgs&amp;&amp;...); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class R, class F, class... BoundArgs&gt;
    <span class='textit'><span class='texttt'>unspecified</span></span> bind(F&amp;&amp;, BoundArgs&amp;&amp;...); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  namespace placeholders {
    <span class='comment'>// <span class='tcode_in_codeblock'><span class='textit'>M</span></span> is the <span class='indexparent'><a class='index'></a></span>implementation-defined number of placeholders
</span>    <span class='textit'><span class='texttt'>see below</span></span> _1; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    <span class='textit'><span class='texttt'>see below</span></span> _2; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
               .
               .
               .
    <span class='textit'><span class='texttt'>see below</span></span> _<span class='textit'>M</span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  }

  <span class='comment'>// 23.14.12, member function adaptors
</span>  template&lt;class R, class T&gt;
    <span class='textit'><span class='texttt'>unspecified</span></span> mem_fn(R T::*) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.14.13, polymorphic function wrappers
</span>  class bad_function_call;

  template&lt;class&gt; class function; <span class='comment'>// not defined
</span>  template&lt;class R, class... ArgTypes&gt; class function&lt;R(ArgTypes...)&gt;;

  template&lt;class R, class... ArgTypes&gt;
    void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  template&lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;
  template&lt;class R, class... ArgTypes&gt;
    bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;
  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;
  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  <span class='comment'>// 23.14.14, searchers
</span>  template&lt;class ForwardIterator, class BinaryPredicate = equal_to&lt;&gt;&gt;
    class default_searcher; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class RandomAccessIterator,
           class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
           class BinaryPredicate = equal_to&lt;&gt;&gt;
    class boyer_moore_searcher;

  template&lt;class RandomAccessIterator,
           class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
           class BinaryPredicate = equal_to&lt;&gt;&gt;
    class boyer_moore_horspool_searcher;

  <span class='comment'>// 23.14.15, hash function primary template
</span>  template&lt;class T&gt;
    struct hash; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 23.14.11, function object binders
</span>  template&lt;class T&gt;
    inline constexpr bool is_bind_expression_v = is_bind_expression&lt;T&gt;::value; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt;
    inline constexpr int is_placeholder_v = is_placeholder&lt;T&gt;::value; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}</pre>
</blockquote>

Change in [meta.type.synop] (23.15.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.15.2</a> Header <span class='texttt'>&lt;type_traits&gt;</span> synopsis <a class='abbr_ref'>[meta.type.synop]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [ratio.syn] (23.16.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.16.2</a> Header <span class='texttt'>&lt;ratio&gt;</span> synopsis <a class='abbr_ref'>[ratio.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [time.syn] (23.17.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.17.2</a> Header <span class='texttt'>&lt;chrono&gt;</span> synopsis <a class='abbr_ref'>[time.syn]</a></h3>
<pre class='codeblock'>
namespace std {
  namespace chrono {
    <span class='comment'>// 23.17.5, class template <span class='tcode_in_codeblock'>duration</span>
</span>    template&lt;class Rep, class Period = ratio&lt;1&gt;&gt; class duration; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

    <span class='comment'>// 23.17.6, class template <span class='tcode_in_codeblock'>time_&shy;point</span>
</span>    template&lt;class Clock, class Duration = typename Clock::duration&gt; class time_point; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  }

  <span class='comment'>// 23.17.4.3, <span class='tcode_in_codeblock'>common_&shy;type</span> specializations
</span>  template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
    struct common_type&lt;chrono::duration&lt;Rep1, Period1&gt;,
                       chrono::duration&lt;Rep2, Period2&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class Clock, class Duration1, class Duration2&gt;
    struct common_type&lt;chrono::time_point&lt;Clock, Duration1&gt;,
                       chrono::time_point&lt;Clock, Duration2&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  namespace chrono {
    <span class='comment'>// 23.17.4, customization traits
</span>    template&lt;class Rep&gt; struct treat_as_floating_point; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep&gt; struct duration_values; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
      inline constexpr bool treat_as_floating_point_v = treat_as_floating_point&lt;Rep&gt;::value;

    <span class='comment'>// 23.17.5.5, <span class='tcode_in_codeblock'>duration</span> arithmetic
</span>    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr common_type_t&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
        operator+(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr common_type_t&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
        operator-(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
    template&lt;class Rep1, class Period, class Rep2&gt;
      constexpr duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
        operator*(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep1, class Rep2, class Period&gt;
      constexpr duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
        operator*(const Rep1&amp; s, const duration&lt;Rep2, Period&gt;&amp; d); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep1, class Period, class Rep2&gt;
      constexpr duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
        operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr common_type_t&lt;Rep1, Rep2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
        operator/(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
    template&lt;class Rep1, class Period, class Rep2&gt;
      constexpr duration&lt;common_type_t&lt;Rep1, Rep2&gt;, Period&gt;
        operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr common_type_t&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
        operator%(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);

    <span class='comment'>// 23.17.5.6, <span class='tcode_in_codeblock'>duration</span> comparisons
</span>    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr bool operator==(const duration&lt;Rep1, Period1&gt;&amp; lhs,
                                const duration&lt;Rep2, Period2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr bool operator!=(const duration&lt;Rep1, Period1&gt;&amp; lhs,
                                const duration&lt;Rep2, Period2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr bool operator&lt; (const duration&lt;Rep1, Period1&gt;&amp; lhs,
                                const duration&lt;Rep2, Period2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr bool operator&lt;=(const duration&lt;Rep1, Period1&gt;&amp; lhs,
                                const duration&lt;Rep2, Period2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr bool operator&gt; (const duration&lt;Rep1, Period1&gt;&amp; lhs,
                                const duration&lt;Rep2, Period2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Rep1, class Period1, class Rep2, class Period2&gt;
      constexpr bool operator&gt;=(const duration&lt;Rep1, Period1&gt;&amp; lhs,
                                const duration&lt;Rep2, Period2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

    <span class='comment'>// 23.17.5.7, <span class='tcode_in_codeblock'>duration_&shy;cast</span>
</span>    template&lt;class ToDuration, class Rep, class Period&gt;
      constexpr ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class ToDuration, class Rep, class Period&gt;
      constexpr ToDuration floor(const duration&lt;Rep, Period&gt;&amp; d); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class ToDuration, class Rep, class Period&gt;
      constexpr ToDuration ceil(const duration&lt;Rep, Period&gt;&amp; d); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class ToDuration, class Rep, class Period&gt;
      constexpr ToDuration round(const duration&lt;Rep, Period&gt;&amp; d); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

    <span class='comment'>// convenience typedefs
</span>    using nanoseconds  = duration&lt;<span class='textit'>signed integer type of at least 64 bits</span>, nano&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    using microseconds = duration&lt;<span class='textit'>signed integer type of at least 55 bits</span>, micro&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    using milliseconds = duration&lt;<span class='textit'>signed integer type of at least 45 bits</span>, milli&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    using seconds      = duration&lt;<span class='textit'>signed integer type of at least 35 bits</span>&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    using minutes      = duration&lt;<span class='textit'>signed integer type of at least 29 bits</span>, ratio&lt;  60&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    using hours        = duration&lt;<span class='textit'>signed integer type of at least 23 bits</span>, ratio&lt;3600&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

    <span class='comment'>// 23.17.6.5, <span class='tcode_in_codeblock'>time_&shy;point</span> arithmetic
</span>    template&lt;class Clock, class Duration1, class Rep2, class Period2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
      constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
        operator+(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
    template&lt;class Rep1, class Period1, class Clock, class Duration2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
      constexpr time_point&lt;Clock, common_type_t&lt;duration&lt;Rep1, Period1&gt;, Duration2&gt;&gt;
        operator+(const duration&lt;Rep1, Period1&gt;&amp; lhs, const time_point&lt;Clock, Duration2&gt;&amp; rhs);
    template&lt;class Clock, class Duration1, class Rep2, class Period2&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
      constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
        operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
    template&lt;class Clock, class Duration1, class Duration2&gt;
      constexpr common_type_t&lt;Duration1, Duration2&gt;
        operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                  const time_point&lt;Clock, Duration2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

    <span class='comment'>// 23.17.6.6, <span class='tcode_in_codeblock'>time_&shy;point</span> comparisons
</span>    template&lt;class Clock, class Duration1, class Duration2&gt;
       constexpr bool operator==(const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                                 const time_point&lt;Clock, Duration2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Clock, class Duration1, class Duration2&gt;
       constexpr bool operator!=(const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                                 const time_point&lt;Clock, Duration2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Clock, class Duration1, class Duration2&gt;
       constexpr bool operator&lt; (const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                                 const time_point&lt;Clock, Duration2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Clock, class Duration1, class Duration2&gt;
       constexpr bool operator&lt;=(const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                                 const time_point&lt;Clock, Duration2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Clock, class Duration1, class Duration2&gt;
       constexpr bool operator&gt; (const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                                 const time_point&lt;Clock, Duration2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class Clock, class Duration1, class Duration2&gt;
       constexpr bool operator&gt;=(const time_point&lt;Clock, Duration1&gt;&amp; lhs,
                                 const time_point&lt;Clock, Duration2&gt;&amp; rhs); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

    <span class='comment'>// 23.17.6.7, <span class='tcode_in_codeblock'>time_&shy;point_&shy;cast</span>
</span>    template&lt;class ToDuration, class Clock, class Duration&gt;
      constexpr time_point&lt;Clock, ToDuration&gt;
        time_point_cast(const time_point&lt;Clock, Duration&gt;&amp; t); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    template&lt;class ToDuration, class Clock, class Duration&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
      constexpr time_point&lt;Clock, ToDuration&gt; floor(const time_point&lt;Clock, Duration&gt;&amp; tp);
    template&lt;class ToDuration, class Clock, class Duration&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
      constexpr time_point&lt;Clock, ToDuration&gt; ceil(const time_point&lt;Clock, Duration&gt;&amp; tp);
    template&lt;class ToDuration, class Clock, class Duration&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
      constexpr time_point&lt;Clock, ToDuration&gt; round(const time_point&lt;Clock, Duration&gt;&amp; tp);

    <span class='comment'>// 23.17.5.9, specialized algorithms
</span>    template&lt;class Rep, class Period&gt;
      constexpr duration&lt;Rep, Period&gt; abs(duration&lt;Rep, Period&gt; d); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

    <span class='comment'>// 23.17.7, clocks
</span>    class system_clock;
    class steady_clock;
    class high_resolution_clock;
  }

  inline namespace literals {
  inline namespace chrono_literals {
    <span class='comment'>// 23.17.5.8, suffixes for duration literals
</span>    constexpr chrono::hours                                 operator""h(unsigned long long); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::duration&lt;<span class='textit'><span class='texttt'>unspecified</span></span>, ratio&lt;3600, 1&gt;&gt; operator""h(long double); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::minutes                               operator""min(unsigned long long); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::duration&lt;<span class='textit'><span class='texttt'>unspecified</span></span>, ratio&lt;60, 1&gt;&gt;   operator""min(long double); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::seconds                               operator""s(unsigned long long); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::duration&lt;<span class='textit'><span class='texttt'>unspecified</span></span>&gt;                 operator""s(long double); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::milliseconds                          operator""ms(unsigned long long); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::duration&lt;<span class='textit'><span class='texttt'>unspecified</span></span>, milli&gt;          operator""ms(long double); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::microseconds                          operator""us(unsigned long long); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::duration&lt;<span class='textit'><span class='texttt'>unspecified</span></span>, micro&gt;          operator""us(long double); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::nanoseconds                           operator""ns(unsigned long long); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr chrono::duration&lt;<span class='textit'><span class='texttt'>unspecified</span></span>, nano&gt;           operator""ns(long double); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  }
  }

  namespace chrono {
    using namespace literals::chrono_literals; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  }
}</pre>
</blockquote>

Change in [charconv.syn] (23.20.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>23.20.1</a> Header <span class='texttt'>&lt;charconv&gt;</span> synopsis <a class='abbr_ref'>[charconv.syn]</a></h3>
<pre class='codeblock'>
namespace std {
  <span class='comment'>// floating-point format for primitive numerical conversion
</span>  enum class <span><span class='tcode_in_codeblock'>chars_&shy;format</span></span> {
    <span><span><span class='tcode_in_codeblock'>scientific</span></span></span> = <span class='textit'><span class='texttt'>unspecified</span></span>,
    <span><span><span class='tcode_in_codeblock'>fixed</span></span></span> = <span class='textit'><span class='texttt'>unspecified</span></span>,
    <span><span><span class='tcode_in_codeblock'>hex</span></span></span> = <span class='textit'><span class='texttt'>unspecified</span></span>,
    <span><span><span class='tcode_in_codeblock'>general</span></span></span> = fixed | scientific
  };

  <span class='comment'>// 23.20.2, primitive numerical output conversion
</span>  struct <span><span class='tcode_in_codeblock'>to_&shy;chars_&shy;result</span></span> {
    char* <span><span><span class='tcode_in_codeblock'>ptr</span></span></span>;
    errc <span><span><span class='tcode_in_codeblock'>ec</span></span></span>;
  }; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  to_chars_result to_chars(char* first, char* last, <span class='textit'><span class='texttt'>see below</span></span> value, int base = 10); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  to_chars_result to_chars(char* first, char* last, float value);
  to_chars_result to_chars(char* first, char* last, double value);
  to_chars_result to_chars(char* first, char* last, long double value);

  to_chars_result to_chars(char* first, char* last, float value, chars_format fmt);
  to_chars_result to_chars(char* first, char* last, double value, chars_format fmt);
  to_chars_result to_chars(char* first, char* last, long double value, chars_format fmt);

  to_chars_result to_chars(char* first, char* last, float value,
                           chars_format fmt, int precision);
  to_chars_result to_chars(char* first, char* last, double value,
                           chars_format fmt, int precision);
  to_chars_result to_chars(char* first, char* last, long double value,
                           chars_format fmt, int precision);

  <span class='comment'>// 23.20.3, primitive numerical input conversion
</span>  struct <span><span class='tcode_in_codeblock'>from_&shy;chars_&shy;result</span></span> {
    const char* <span><span><span class='tcode_in_codeblock'>ptr</span></span></span>;
    errc <span><span><span class='tcode_in_codeblock'>ec</span></span></span>;
  }; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  from_chars_result from_chars(const char* first, const char* last,
                               <span class='textit'><span class='texttt'>see below</span></span>&amp; value, int base = 10); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  from_chars_result from_chars(const char* first, const char* last, float&amp; value,
                               chars_format fmt = chars_format::general);
  from_chars_result from_chars(const char* first, const char* last, double&amp; value,
                               chars_format fmt = chars_format::general);
  from_chars_result from_chars(const char* first, const char* last, long double&amp; value,
                               chars_format fmt = chars_format::general);
}</pre>
</blockquote>

Change in [string.syn] (24.3.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>24.3.1</a> Header <span class='texttt'>&lt;string&gt;</span> synopsis <a class='abbr_ref'>[string.syn]</a></h3>
<pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// 24.2, character traits
</span>  template&lt;class charT&gt; struct char_traits; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct char_traits&lt;char&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct char_traits&lt;char16_t&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct char_traits&lt;char32_t&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct char_traits&lt;wchar_t&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 24.3.2, <span class='tcode_in_codeblock'>basic_&shy;string</span></span>
</pre>
</blockquote>

Change in [cstring.syn] (24.5.3):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>24.5.3</a> Header <span class='texttt'>&lt;cstring&gt;</span> synopsis <a class='abbr_ref'>[cstring.syn]</a></h3>
<pre class='codeblock'>
namespace std {
  using size_t = <span class='textit'>see 21.2.4</span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  void* memcpy(void* s1, const void* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  void* memmove(void* s1, const void* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  char* strcpy(char* s1, const char* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  char* strncpy(char* s1, const char* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  char* strcat(char* s1, const char* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  char* strncat(char* s1, const char* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  int memcmp(const void* s1, const void* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  int strcmp(const char* s1, const char* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  int strcoll(const char* s1, const char* s2);
  int strncmp(const char* s1, const char* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  size_t strxfrm(char* s1, const char* s2, size_t n);
  const void* memchr(const void* s, int c, size_t n);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  void* memchr(void* s, int c, size_t n);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  const char* strchr(const char* s, int c);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  char* strchr(char* s, int c);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  size_t strcspn(const char* s1, const char* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  const char* strpbrk(const char* s1, const char* s2);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  char* strpbrk(char* s1, const char* s2);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  const char* strrchr(const char* s, int c);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  char* strrchr(char* s, int c);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  size_t strspn(const char* s1, const char* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  const char* strstr(const char* s1, const char* s2);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  char* strstr(char* s1, const char* s2);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  char* strtok(char* s1, const char* s2);
  void* memset(void* s, int c, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  char* strerror(int errnum);
  size_t strlen(const char* s); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}

#define NULL <span class='textit'>see 21.2.3</span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins></pre>
</blockquote>

Change in [string.view.synop] (24.4.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>24.4.1</a> Header <span class='texttt'>&lt;string_&shy;view&gt;</span> synopsis <a class='abbr_ref'>[string.view.synop]</a></h3>
<pre class='codeblock'>
namespace std {
  <span class='comment'>// 24.4.2, class template <span class='tcode_in_codeblock'>basic_&shy;string_&shy;view</span>
</span>  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
  class basic_string_view; <ins><span class='comment'>// <span class='textit'>freestanding, partial</span></span></ins>

  <span class='comment'>// 24.4.3, non-member comparison functions
</span>  template&lt;class charT, class traits&gt;
    constexpr bool operator==(basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class charT, class traits&gt;
    constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class charT, class traits&gt;
    constexpr bool operator&lt; (basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class charT, class traits&gt;
    constexpr bool operator&gt; (basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class charT, class traits&gt;
    constexpr bool operator&lt;=(basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class charT, class traits&gt;
    constexpr bool operator&gt;=(basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  <span class='comment'>// see 24.4.3, sufficient additional overloads of comparison functions<ins>, <span class='textit'>freestanding</span></ins>
</span>
  <span class='comment'>// 24.4.4, inserters and extractors
</span>  template&lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
                 basic_string_view&lt;charT, traits&gt; str);

  <span class='comment'>// <span class='tcode_in_codeblock'>basic_&shy;string_&shy;view</span> typedef names
</span>  using string_view    = basic_string_view&lt;char&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using u16string_view = basic_string_view&lt;char16_t&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using u32string_view = basic_string_view&lt;char32_t&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using wstring_view   = basic_string_view&lt;wchar_t&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 24.4.5, hash support
</span>  template&lt;class T&gt; struct hash; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct hash&lt;string_view&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct hash&lt;u16string_view&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct hash&lt;u32string_view&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;&gt; struct hash&lt;wstring_view&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  inline namespace literals {
  inline namespace string_view_literals {
    <span class='comment'>// 24.4.6, suffix for <span class='tcode_in_codeblock'>basic_&shy;string_&shy;view</span> literals
</span>    constexpr string_view    operator""sv(const char* str, size_t len) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr u16string_view operator""sv(const char16_t* str, size_t len) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr u32string_view operator""sv(const char32_t* str, size_t len) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr wstring_view   operator""sv(const wchar_t* str, size_t len) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  }
  }
}
</pre>
</blockquote>

Change in [string.view.template] (24.4.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>24.4.2</a> Class template <span class='texttt'>basic_&shy;string_&shy;view</span> <a class='abbr_ref'>[string.view.template]</a></h3>
<pre class='codeblock'>
template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
class basic_string_view {
public:
  <span class='comment'>// types
</span>  using traits_type            = traits;
  using value_type             = charT;
  using pointer                = value_type*;
  using const_pointer          = const value_type*;
  using reference              = value_type&amp;;
  using const_reference        = const value_type&amp;;
  using const_iterator         = <span class='textit'>implementation-defined</span>; <span class='comment'>// see 24.4.2.2
</span>  using iterator               = const_iterator;<a class='footnotenum'>232</a>
  using const_reverse_iterator = reverse_iterator&lt;const_iterator&gt;;
  using reverse_iterator       = const_reverse_iterator;
  using size_type              = size_t;
  using difference_type        = ptrdiff_t;
  static constexpr size_type npos = size_type(-1);

  <span class='comment'>// 24.4.2.1, construction and assignment
</span>  constexpr basic_string_view() noexcept;
  constexpr basic_string_view(const basic_string_view&amp;) noexcept = default;
  constexpr basic_string_view&amp; operator=(const basic_string_view&amp;) noexcept = default;
  constexpr basic_string_view(const charT* str);
  constexpr basic_string_view(const charT* str, size_type len);

  <span class='comment'>// 24.4.2.2, iterator support
</span>  constexpr const_iterator begin() const noexcept;
  constexpr const_iterator end() const noexcept;
  constexpr const_iterator cbegin() const noexcept;
  constexpr const_iterator cend() const noexcept;
  constexpr const_reverse_iterator rbegin() const noexcept;
  constexpr const_reverse_iterator rend() const noexcept;
  constexpr const_reverse_iterator crbegin() const noexcept;
  constexpr const_reverse_iterator crend() const noexcept;

  <span class='comment'>// 24.4.2.3, capacity
</span>  constexpr size_type size() const noexcept;
  constexpr size_type length() const noexcept;
  constexpr size_type max_size() const noexcept;
  [[nodiscard]] constexpr bool empty() const noexcept;

  <span class='comment'>// 24.4.2.4, element access
</span>  constexpr const_reference operator[](size_type pos) const;
  constexpr const_reference at(size_type pos) const; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
  constexpr const_reference front() const;
  constexpr const_reference back() const;
  constexpr const_pointer data() const noexcept;

  <span class='comment'>// 24.4.2.5, modifiers
</span>  constexpr void remove_prefix(size_type n);
  constexpr void remove_suffix(size_type n);
  constexpr void swap(basic_string_view&amp; s) noexcept;

  <span class='comment'>// 24.4.2.6, string operations
</span>  size_type copy(charT* s, size_type n, size_type pos = 0) const; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>

  constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>

  constexpr int compare(basic_string_view s) const noexcept;
  constexpr int compare(size_type pos1, size_type n1, basic_string_view s) const; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
  constexpr int compare(size_type pos1, size_type n1, basic_string_view s,
                        size_type pos2, size_type n2) const; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
  constexpr int compare(const charT* s) const;
  constexpr int compare(size_type pos1, size_type n1, const charT* s) const; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
  constexpr int compare(size_type pos1, size_type n1, const charT* s, size_type n2) const; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>

  constexpr bool starts_with(basic_string_view x) const noexcept;
  constexpr bool starts_with(charT x) const noexcept;
  constexpr bool starts_with(const charT* x) const;
  constexpr bool ends_with(basic_string_view x) const noexcept;
  constexpr bool ends_with(charT x) const noexcept;
  constexpr bool ends_with(const charT* x) const;

  constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;
  constexpr size_type find(charT c, size_type pos = 0) const noexcept;
  constexpr size_type find(const charT* s, size_type pos, size_type n) const;
  constexpr size_type find(const charT* s, size_type pos = 0) const;
  constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;
  constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
  constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
  constexpr size_type rfind(const charT* s, size_type pos = npos) const;

  constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;
  constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
  constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
  constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
  constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;
  constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
  constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
  constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
  constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;
  constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
  constexpr size_type find_first_not_of(const charT* s, size_type pos,
                                        size_type n) const;
  constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
  constexpr size_type find_last_not_of(basic_string_view s,
                                       size_type pos = npos) const noexcept;
  constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
  constexpr size_type find_last_not_of(const charT* s, size_type pos,
                                       size_type n) const;
  constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;

private:
  const_pointer data_; <span class='comment'>// <span class='textit'>exposition only</span>
</span>  size_type size_;     <span class='comment'>// <span class='textit'>exposition only</span>
</span>};
</pre>
</blockquote>

Change in [cwchar.syn] (24.5.4):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>24.5.4</a> Header <span class='texttt'>&lt;cwchar&gt;</span> synopsis <a class='abbr_ref'>[cwchar.syn]</a></h3>
<pre class='codeblock'>
namespace std {
  using size_t = <span class='textit'>see 21.2.4</span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using mbstate_t = <span class='textit'><span class='texttt'>see below</span></span>;
  using wint_t = <span class='textit'><span class='texttt'>see below</span></span>;

  struct tm;

  int fwprintf(FILE* stream, const wchar_t* format, ...);
  int fwscanf(FILE* stream, const wchar_t* format, ...);
  int swprintf(wchar_t* s, size_t n, const wchar_t* format, ...);
  int swscanf(const wchar_t* s, const wchar_t* format, ...);
  int vfwprintf(FILE* stream, const wchar_t* format, va_list arg);
  int vfwscanf(FILE* stream, const wchar_t* format, va_list arg);
  int vswprintf(wchar_t* s, size_t n, const wchar_t* format, va_list arg);
  int vswscanf(const wchar_t* s, const wchar_t* format, va_list arg);
  int vwprintf(const wchar_t* format, va_list arg);
  int vwscanf(const wchar_t* format, va_list arg);
  int wprintf(const wchar_t* format, ...);
  int wscanf(const wchar_t* format, ...);
  wint_t fgetwc(FILE* stream);
  wchar_t* fgetws(wchar_t* s, int n, FILE* stream);
  wint_t fputwc(wchar_t c, FILE* stream);
  int fputws(const wchar_t* s, FILE* stream);
  int fwide(FILE* stream, int mode);
  wint_t getwc(FILE* stream);
  wint_t getwchar();
  wint_t putwc(wchar_t c, FILE* stream);
  wint_t putwchar(wchar_t c);
  wint_t ungetwc(wint_t c, FILE* stream);
  double wcstod(const wchar_t* nptr, wchar_t** endptr);
  float wcstof(const wchar_t* nptr, wchar_t** endptr);
  long double wcstold(const wchar_t* nptr, wchar_t** endptr);
  long int wcstol(const wchar_t* nptr, wchar_t** endptr, int base);
  long long int wcstoll(const wchar_t* nptr, wchar_t** endptr, int base);
  unsigned long int wcstoul(const wchar_t* nptr, wchar_t** endptr, int base);
  unsigned long long int wcstoull(const wchar_t* nptr, wchar_t** endptr, int base);
  wchar_t* wcscpy(wchar_t* s1, const wchar_t* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  wchar_t* wcsncpy(wchar_t* s1, const wchar_t* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  wchar_t* wmemcpy(wchar_t* s1, const wchar_t* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  wchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  wchar_t* wcscat(wchar_t* s1, const wchar_t* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  wchar_t* wcsncat(wchar_t* s1, const wchar_t* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  int wcscmp(const wchar_t* s1, const wchar_t* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  int wcscoll(const wchar_t* s1, const wchar_t* s2);
  int wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  size_t wcsxfrm(wchar_t* s1, const wchar_t* s2, size_t n);
  int wmemcmp(const wchar_t* s1, const wchar_t* s2, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  const wchar_t* wcschr(const wchar_t* s, wchar_t c);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  wchar_t* wcschr(wchar_t* s, wchar_t c);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  size_t wcscspn(const wchar_t* s1, const wchar_t* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  wchar_t* wcspbrk(wchar_t* s1, const wchar_t* s2);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  wchar_t* wcsrchr(wchar_t* s, wchar_t c);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  size_t wcsspn(const wchar_t* s1, const wchar_t* s2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  wchar_t* wcsstr(wchar_t* s1, const wchar_t* s2);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  wchar_t* wcstok(wchar_t* s1, const wchar_t* s2, wchar_t** ptr); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  wchar_t* wmemchr(wchar_t* s, wchar_t c, size_t n);  <span class='comment'>// see 20.2<ins><span class='textit'>, freestanding</span></ins>
</span>  size_t wcslen(const wchar_t* s); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  wchar_t* wmemset(wchar_t* s, wchar_t c, size_t n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  size_t wcsftime(wchar_t* s, size_t maxsize, const wchar_t* format, const struct tm* timeptr);
  wint_t btowc(int c);
  int wctob(wint_t c);

  <span class='comment'>// 24.5.6, multibyte / wide string and character conversion functions
</span>  int mbsinit(const mbstate_t* ps);
  size_t mbrlen(const char* s, size_t n, mbstate_t* ps);
  size_t mbrtowc(wchar_t* pwc, const char* s, size_t n, mbstate_t* ps);
  size_t wcrtomb(char* s, wchar_t wc, mbstate_t* ps);
  size_t mbsrtowcs(wchar_t* dst, const char** src, size_t len, mbstate_t* ps);
  size_t wcsrtombs(char* dst, const wchar_t** src, size_t len, mbstate_t* ps);
}

#define NULL <span class='textit'>see 21.2.3</span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define WCHAR_MAX <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define WCHAR_MIN <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define WEOF <span class='textit'><span class='texttt'>see below</span></span> <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins></pre>
</blockquote>

Change in [array.syn] (26.3.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>26.3.2</a> Header <span class='texttt'>&lt;array&gt;</span> synopsis <a class='abbr_ref'>[array.syn]</a></h3>
<pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// 26.3.7, class template <span class='tcode_in_codeblock'>array</span>
</span>  template&lt;class T, size_t N&gt; struct array; <ins><span class='comment'>// <span class='textit'>freestanding, partial</span></span></ins>

  template&lt;class T, size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator==(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template&lt;class T, size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator!=(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template&lt;class T, size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&lt; (const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template&lt;class T, size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&gt; (const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template&lt;class T, size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&lt;=(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template&lt;class T, size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    bool operator&gt;=(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);
  template&lt;class T, size_t N&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    void swap(array&lt;T, N&gt;&amp; x, array&lt;T, N&gt;&amp; y) noexcept(noexcept(x.swap(y)));

  template&lt;class T&gt; class tuple_size; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class T&gt; class tuple_element; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, size_t N&gt;
    struct tuple_size&lt;array&lt;T, N&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class T, size_t N&gt;
    struct tuple_element&lt;I, array&lt;T, N&gt;&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class T, size_t N&gt;
    constexpr T&amp; get(array&lt;T, N&gt;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class T, size_t N&gt;
    constexpr T&amp;&amp; get(array&lt;T, N&gt;&amp;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class T, size_t N&gt;
    constexpr const T&amp; get(const array&lt;T, N&gt;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;size_t I, class T, size_t N&gt;
    constexpr const T&amp;&amp; get(const array&lt;T, N&gt;&amp;&amp;) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}
</pre>
</blockquote>

Change in [array.syn] (26.3.2):
<blockquote class="std">
<pre class='codeblock'>
    <span class='comment'>// element access
</span>    constexpr reference       operator[](size_type n);
    constexpr const_reference operator[](size_type n) const;
    constexpr reference       at(size_type n); <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
    constexpr const_reference at(size_type n) const; <ins><span class='comment'>// <span class='textit'>freestanding, omit</span></span></ins>
    constexpr reference       front();
    constexpr const_reference front() const;
    constexpr reference       back();
    constexpr const_reference back() const;
</pre>
</blockquote>

Change in [iterator.synopsis] (27.3):
<blockquote class="std">
<h2 ><a class='secnum' style='min-width:88pt'>27.3</a> Header <span class='texttt'>&lt;iterator&gt;</span>&nbsp;synopsis <a class='abbr_ref'>[iterator.synopsis]</a></h2>
<pre class='codeblock'>
namespace std {
  <span class='comment'>// 27.4, primitives
</span>  template&lt;class Iterator&gt; struct iterator_traits; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt; struct iterator_traits&lt;T*&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  struct input_iterator_tag { }; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  struct output_iterator_tag { }; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  struct forward_iterator_tag: public input_iterator_tag { }; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  struct bidirectional_iterator_tag: public forward_iterator_tag { }; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  struct random_access_iterator_tag: public bidirectional_iterator_tag { }; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 27.4.3, iterator operations
</span>  template&lt;class InputIterator, class Distance&gt;
    constexpr void
      advance(InputIterator&amp; i, Distance n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator&gt;
    constexpr typename iterator_traits&lt;InputIterator&gt;::difference_type
      distance(InputIterator first, InputIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator&gt;
    constexpr InputIterator
      next(InputIterator x,
           typename iterator_traits&lt;InputIterator&gt;::difference_type n = 1); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class BidirectionalIterator&gt;
    constexpr BidirectionalIterator
      prev(BidirectionalIterator x,
           typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type n = 1); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 27.5, predefined iterators
</span>  template&lt;class Iterator&gt; class reverse_iterator; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator==(
      const reverse_iterator&lt;Iterator1&gt;&amp; x,
      const reverse_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator&lt;(
      const reverse_iterator&lt;Iterator1&gt;&amp; x,
      const reverse_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator!=(
      const reverse_iterator&lt;Iterator1&gt;&amp; x,
      const reverse_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator&gt;(
      const reverse_iterator&lt;Iterator1&gt;&amp; x,
      const reverse_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator&gt;=(
      const reverse_iterator&lt;Iterator1&gt;&amp; x,
      const reverse_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator&lt;=(
      const reverse_iterator&lt;Iterator1&gt;&amp; x,
      const reverse_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class Iterator1, class Iterator2&gt;
    constexpr auto operator-(
      const reverse_iterator&lt;Iterator1&gt;&amp; x,
      const reverse_iterator&lt;Iterator2&gt;&amp; y) -&gt; decltype(y.base() - x.base()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator&gt;
    constexpr reverse_iterator&lt;Iterator&gt;
      operator+(
    typename reverse_iterator&lt;Iterator&gt;::difference_type n,
    const reverse_iterator&lt;Iterator&gt;&amp; x); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class Iterator&gt;
    constexpr reverse_iterator&lt;Iterator&gt; make_reverse_iterator(Iterator i); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class Container&gt; class back_insert_iterator;
  template&lt;class Container&gt;
    back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);

  template&lt;class Container&gt; class front_insert_iterator;
  template&lt;class Container&gt;
    front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x);

  template&lt;class Container&gt; class insert_iterator;
  template&lt;class Container&gt;
    insert_iterator&lt;Container&gt; inserter(Container&amp; x, typename Container::iterator i);

  template&lt;class Iterator&gt; class move_iterator; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator==(
      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator!=(
      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator&lt;(
      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator&lt;=(
      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator&gt;(
      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator&gt;=(
      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class Iterator1, class Iterator2&gt;
    constexpr auto operator-(
    const move_iterator&lt;Iterator1&gt;&amp; x,
    const move_iterator&lt;Iterator2&gt;&amp; y) -&gt; decltype(x.base() - y.base()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class Iterator&gt;
    constexpr move_iterator&lt;Iterator&gt; operator+( <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
      typename move_iterator&lt;Iterator&gt;::difference_type n, const move_iterator&lt;Iterator&gt;&amp; x);
  template&lt;class Iterator&gt;
    constexpr move_iterator&lt;Iterator&gt; make_move_iterator(Iterator i); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 27.6, stream iterators
</span>  template&lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;,
           class Distance = ptrdiff_t&gt;
  class istream_iterator;
  template&lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
            const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);
  template&lt;class T, class charT, class traits, class Distance&gt;
    bool operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
            const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);

  template&lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;&gt;
      class ostream_iterator;

  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
    class istreambuf_iterator;
  template&lt;class charT, class traits&gt;
    bool operator==(const istreambuf_iterator&lt;charT,traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT,traits&gt;&amp; b);
  template&lt;class charT, class traits&gt;
    bool operator!=(const istreambuf_iterator&lt;charT,traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT,traits&gt;&amp; b);

  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
    class ostreambuf_iterator;

  <span class='comment'>// 27.7, range access
</span>  template&lt;class C&gt; constexpr auto begin(C&amp; c) -&gt; decltype(c.begin()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto begin(const C&amp; c) -&gt; decltype(c.begin()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto end(C&amp; c) -&gt; decltype(c.end()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto end(const C&amp; c) -&gt; decltype(c.end()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, size_t N&gt; constexpr T* begin(T (&amp;array)[N]) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, size_t N&gt; constexpr T* end(T (&amp;array)[N]) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto cbegin(const C&amp; c) noexcept(noexcept(std::begin(c)))
    -&gt; decltype(std::begin(c)); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto cend(const C&amp; c) noexcept(noexcept(std::end(c)))
    -&gt; decltype(std::end(c)); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto rbegin(C&amp; c) -&gt; decltype(c.rbegin()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto rbegin(const C&amp; c) -&gt; decltype(c.rbegin()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto rend(C&amp; c) -&gt; decltype(c.rend()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto rend(const C&amp; c) -&gt; decltype(c.rend()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, size_t N&gt; constexpr reverse_iterator&lt;T*&gt; rbegin(T (&amp;array)[N]); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, size_t N&gt; constexpr reverse_iterator&lt;T*&gt; rend(T (&amp;array)[N]); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class E&gt; constexpr reverse_iterator&lt;const E*&gt; rbegin(initializer_list&lt;E&gt; il); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class E&gt; constexpr reverse_iterator&lt;const E*&gt; rend(initializer_list&lt;E&gt; il); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto crbegin(const C&amp; c) -&gt; decltype(std::rbegin(c)); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto crend(const C&amp; c) -&gt; decltype(std::rend(c)); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 27.8, container access
</span>  template&lt;class C&gt; constexpr auto size(const C&amp; c) -&gt; decltype(c.size()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, size_t N&gt; constexpr size_t size(const T (&amp;array)[N]) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; [[nodiscard]] constexpr auto empty(const C&amp; c) -&gt; decltype(c.empty()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, size_t N&gt; [[nodiscard]] constexpr bool empty(const T (&amp;array)[N]) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class E&gt; [[nodiscard]] constexpr bool empty(initializer_list&lt;E&gt; il) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto data(C&amp; c) -&gt; decltype(c.data()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class C&gt; constexpr auto data(const C&amp; c) -&gt; decltype(c.data()); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, size_t N&gt; constexpr T* data(T (&amp;array)[N]) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class E&gt; constexpr const E* data(initializer_list&lt;E&gt; il) noexcept; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}</pre>
</blockquote>

Change in [algorithm.syn] (28.2):
<blockquote class="std">
<h2 ><a class='secnum' style='min-width:88pt'>28.2</a> Header <span class='texttt'>&lt;algorithm&gt;</span> synopsis <a class='abbr_ref'>[algorithm.syn]</a></h2>
<pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// 28.5, non-modifying sequence operations
</span>  <span class='comment'>// 28.5.1, all of
</span>  template&lt;class InputIterator, class Predicate&gt;
    constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    bool all_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                ForwardIterator first, ForwardIterator last, Predicate pred);

  <span class='comment'>// 28.5.2, any of
</span>  template&lt;class InputIterator, class Predicate&gt;
    constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    bool any_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                ForwardIterator first, ForwardIterator last, Predicate pred);

  <span class='comment'>// 28.5.3, none of
</span>  template&lt;class InputIterator, class Predicate&gt;
    constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    bool none_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                 ForwardIterator first, ForwardIterator last, Predicate pred);

  <span class='comment'>// 28.5.4, for each
</span>  template&lt;class InputIterator, class Function&gt;
    constexpr Function for_each(InputIterator first, InputIterator last, Function f); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Function&gt;
    void for_each(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                  ForwardIterator first, ForwardIterator last, Function f);
  template&lt;class InputIterator, class Size, class Function&gt;
    constexpr InputIterator for_each_n(InputIterator first, Size n, Function f); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class Function&gt;
    ForwardIterator for_each_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                               ForwardIterator first, Size n, Function f);

  <span class='comment'>// 28.5.5, find
</span>  template&lt;class InputIterator, class T&gt;
    constexpr InputIterator find(InputIterator first, InputIterator last,
                                 const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    ForwardIterator find(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                         ForwardIterator first, ForwardIterator last,
                         const T&amp; value);
  template&lt;class InputIterator, class Predicate&gt;
    constexpr InputIterator find_if(InputIterator first, InputIterator last,
                                    Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    ForwardIterator find_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                            ForwardIterator first, ForwardIterator last,
                            Predicate pred);
  template&lt;class InputIterator, class Predicate&gt;
    constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
                                        Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    ForwardIterator find_if_not(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                ForwardIterator first, ForwardIterator last,
                                Predicate pred);

  <span class='comment'>// 28.5.6, find end
</span>  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1
      find_end(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate&gt;
    ForwardIterator1
      find_end(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  <span class='comment'>// 28.5.7, find first
</span>  template&lt;class InputIterator, class ForwardIterator&gt;
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class ForwardIterator, class BinaryPredicate&gt;
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2,
                    BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1
      find_first_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate&gt;
    ForwardIterator1
      find_first_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2,
                    BinaryPredicate pred);

  <span class='comment'>// 28.5.8, adjacent find
</span>  template&lt;class ForwardIterator&gt;
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class BinaryPredicate&gt;
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator
      adjacent_find(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                    ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator
      adjacent_find(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                    ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred);

  <span class='comment'>// 28.5.9, count
</span>  template&lt;class InputIterator, class T&gt;
    constexpr typename iterator_traits&lt;InputIterator&gt;::difference_type
      count(InputIterator first, InputIterator last, const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    typename iterator_traits&lt;ForwardIterator&gt;::difference_type
      count(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>            ForwardIterator first, ForwardIterator last, const T&amp; value);
  template&lt;class InputIterator, class Predicate&gt;
    constexpr typename iterator_traits&lt;InputIterator&gt;::difference_type
      count_if(InputIterator first, InputIterator last, Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    typename iterator_traits&lt;ForwardIterator&gt;::difference_type
      count_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator first, ForwardIterator last, Predicate pred);

  <span class='comment'>// 28.5.10, mismatch
</span>  template&lt;class InputIterator1, class InputIterator2&gt;
    constexpr pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    constexpr pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2&gt;
    constexpr pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    constexpr pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    pair&lt;ForwardIterator1, ForwardIterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate&gt;
    pair&lt;ForwardIterator1, ForwardIterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    pair&lt;ForwardIterator1, ForwardIterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate&gt;
    pair&lt;ForwardIterator1, ForwardIterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  <span class='comment'>// 28.5.11, equal
</span>  template&lt;class InputIterator1, class InputIterator2&gt;
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2&gt;
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  <span class='comment'>// 28.5.12, is permutation
</span>  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2,
                                  BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.5.13, search
</span>  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1
      search(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate&gt;
    ForwardIterator1
      search(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
  template&lt;class ForwardIterator, class Size, class T&gt;
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T&amp; value,
               BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class T&gt;
    ForwardIterator
      search_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator first, ForwardIterator last,
               Size count, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class T,
           class BinaryPredicate&gt;
    ForwardIterator
      search_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>               ForwardIterator first, ForwardIterator last,
               Size count, const T&amp; value,
               BinaryPredicate pred);

  template&lt;class ForwardIterator, class Searcher&gt;
    constexpr ForwardIterator
      search(ForwardIterator first, ForwardIterator last, const Searcher&amp; searcher); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.6, mutating sequence operations
</span>  <span class='comment'>// 28.6.1, copy
</span>  template&lt;class InputIterator, class OutputIterator&gt;
    constexpr OutputIterator copy(InputIterator first, InputIterator last,
                                  OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2 copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);
  template&lt;class InputIterator, class Size, class OutputIterator&gt;
    constexpr OutputIterator copy_n(InputIterator first, Size n,
                                    OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class Size,
           class ForwardIterator2&gt;
    ForwardIterator2 copy_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                            ForwardIterator1 first, Size n,
                            ForwardIterator2 result);
  template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
    constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                     OutputIterator result, Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate&gt;
    ForwardIterator2 copy_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result, Predicate pred);
  template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
    constexpr BidirectionalIterator2
      copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.6.2, move
</span>  template&lt;class InputIterator, class OutputIterator&gt;
    constexpr OutputIterator move(InputIterator first, InputIterator last,
                                  OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2&gt;
    ForwardIterator2 move(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);
  template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
    constexpr BidirectionalIterator2
      move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.6.3, swap
</span>  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2 swap_ranges(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                 ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2);
  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    void iter_swap(ForwardIterator1 a, ForwardIterator2 b); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.6.4, transform
</span>  template&lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;
    constexpr OutputIterator
      transform(InputIterator first, InputIterator last,
                OutputIterator result, UnaryOperation op); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator,
           class BinaryOperation&gt;
    constexpr OutputIterator
      transform(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, OutputIterator result,
                BinaryOperation binary_op); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class UnaryOperation&gt;
    ForwardIterator2
      transform(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result, UnaryOperation op);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class BinaryOperation&gt;
    ForwardIterator
      transform(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator result,
                BinaryOperation binary_op);

  <span class='comment'>// 28.6.5, replace
</span>  template&lt;class ForwardIterator, class T&gt;
    constexpr void replace(ForwardIterator first, ForwardIterator last,
                           const T&amp; old_value, const T&amp; new_value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    void replace(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                 ForwardIterator first, ForwardIterator last,
                 const T&amp; old_value, const T&amp; new_value);
  template&lt;class ForwardIterator, class Predicate, class T&gt;
    constexpr void replace_if(ForwardIterator first, ForwardIterator last,
                              Predicate pred, const T&amp; new_value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate, class T&gt;
    void replace_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                    ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T&amp; new_value);
  template&lt;class InputIterator, class OutputIterator, class T&gt;
    constexpr OutputIterator replace_copy(InputIterator first, InputIterator last,
                                          OutputIterator result,
                                          const T&amp; old_value, const T&amp; new_value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T&gt;
    ForwardIterator2 replace_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                  ForwardIterator1 first, ForwardIterator1 last,
                                  ForwardIterator2 result,
                                  const T&amp; old_value, const T&amp; new_value);
  template&lt;class InputIterator, class OutputIterator, class Predicate, class T&gt;
    constexpr OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                             OutputIterator result,
                                             Predicate pred, const T&amp; new_value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate, class T&gt;
    ForwardIterator2 replace_copy_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                     ForwardIterator1 first, ForwardIterator1 last,
                                     ForwardIterator2 result,
                                     Predicate pred, const T&amp; new_value);

  <span class='comment'>// 28.6.6, fill
</span>  template&lt;class ForwardIterator, class T&gt;
    constexpr void fill(ForwardIterator first, ForwardIterator last, const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    void fill(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>              ForwardIterator first, ForwardIterator last, const T&amp; value);
  template&lt;class OutputIterator, class Size, class T&gt;
    constexpr OutputIterator fill_n(OutputIterator first, Size n, const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator,
           class Size, class T&gt;
    ForwardIterator fill_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                           ForwardIterator first, Size n, const T&amp; value);

  <span class='comment'>// 28.6.7, generate
</span>  template&lt;class ForwardIterator, class Generator&gt;
    constexpr void generate(ForwardIterator first, ForwardIterator last,
                            Generator gen); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Generator&gt;
    void generate(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                  ForwardIterator first, ForwardIterator last,
                  Generator gen);
  template&lt;class OutputIterator, class Size, class Generator&gt;
    constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class Generator&gt;
    ForwardIterator generate_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                               ForwardIterator first, Size n, Generator gen);

  <span class='comment'>// 28.6.8, remove
</span>  template&lt;class ForwardIterator, class T&gt;
    constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                                     const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    ForwardIterator remove(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                           ForwardIterator first, ForwardIterator last,
                           const T&amp; value);
  template&lt;class ForwardIterator, class Predicate&gt;
    constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                                        Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    ForwardIterator remove_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                              ForwardIterator first, ForwardIterator last,
                              Predicate pred);
  template&lt;class InputIterator, class OutputIterator, class T&gt;
    constexpr OutputIterator
      remove_copy(InputIterator first, InputIterator last,
                  OutputIterator result, const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class T&gt;
    ForwardIterator2
      remove_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, const T&amp; value);
  template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
    constexpr OutputIterator
      remove_copy_if(InputIterator first, InputIterator last,
                     OutputIterator result, Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate&gt;
    ForwardIterator2
      remove_copy_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result, Predicate pred);

  <span class='comment'>// 28.6.9, unique
</span>  template&lt;class ForwardIterator&gt;
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class BinaryPredicate&gt;
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                                     BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator unique(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                           ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator unique(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                           ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred);
  template&lt;class InputIterator, class OutputIterator&gt;
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result, BinaryPredicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2
      unique_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate&gt;
    ForwardIterator2
      unique_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, BinaryPredicate pred);

  <span class='comment'>// 28.6.10, reverse
</span>  template&lt;class BidirectionalIterator&gt;
    void reverse(BidirectionalIterator first, BidirectionalIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class BidirectionalIterator&gt;
    void reverse(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                 BidirectionalIterator first, BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class OutputIterator&gt;
    constexpr OutputIterator
      reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
                   OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator&gt;
    ForwardIterator
      reverse_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                   BidirectionalIterator first, BidirectionalIterator last,
                   ForwardIterator result);

  <span class='comment'>// 28.6.11, rotate
</span>  template&lt;class ForwardIterator&gt;
    ForwardIterator rotate(ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator rotate(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                           ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);
  template&lt;class ForwardIterator, class OutputIterator&gt;
    constexpr OutputIterator
      rotate_copy(ForwardIterator first, ForwardIterator middle,
                  ForwardIterator last, OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2
      rotate_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                  ForwardIterator1 first, ForwardIterator1 middle,
                  ForwardIterator1 last, ForwardIterator2 result);

  <span class='comment'>// 28.6.12, sample
</span>  template&lt;class PopulationIterator, class SampleIterator,
           class Distance, class UniformRandomBitGenerator&gt;
    SampleIterator sample(PopulationIterator first, PopulationIterator last,
                          SampleIterator out, Distance n,
                          UniformRandomBitGenerator&amp;&amp; g); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.6.13, shuffle
</span>  template&lt;class RandomAccessIterator, class UniformRandomBitGenerator&gt;
    void shuffle(RandomAccessIterator first,
                 RandomAccessIterator last,
                 UniformRandomBitGenerator&amp;&amp; g); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.7.4, partitions
</span>  template&lt;class InputIterator, class Predicate&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    bool is_partitioned(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                        ForwardIterator first, ForwardIterator last, Predicate pred);

  template&lt;class ForwardIterator, class Predicate&gt;
    ForwardIterator partition(ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    ForwardIterator partition(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                              ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);
  template&lt;class BidirectionalIterator, class Predicate&gt;
    BidirectionalIterator stable_partition(BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template&lt;class ExecutionPolicy, class BidirectionalIterator, class Predicate&gt;
    BidirectionalIterator stable_partition(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                           BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template&lt;class InputIterator, class OutputIterator1,
           class OutputIterator2, class Predicate&gt;
    constexpr pair&lt;OutputIterator1, OutputIterator2&gt;
      partition_copy(InputIterator first, InputIterator last,
                     OutputIterator1 out_true, OutputIterator2 out_false,
                     Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
           class ForwardIterator2, class Predicate&gt;
    pair&lt;ForwardIterator1, ForwardIterator2&gt;
      partition_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     ForwardIterator first, ForwardIterator last,
                     ForwardIterator1 out_true, ForwardIterator2 out_false,
                     Predicate pred);
  template&lt;class ForwardIterator, class Predicate&gt;
    constexpr ForwardIterator
      partition_point(ForwardIterator first, ForwardIterator last,
                      Predicate pred); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.7, sorting and related operations
</span>  <span class='comment'>// 28.7.1, sorting
</span>  template&lt;class RandomAccessIterator&gt;
    void sort(RandomAccessIterator first, RandomAccessIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class RandomAccessIterator, class Compare&gt;
    void sort(RandomAccessIterator first, RandomAccessIterator last,
              Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>              RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>              RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void partial_sort(RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class RandomAccessIterator, class Compare&gt;
    void partial_sort(RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);
  template&lt;class InputIterator, class RandomAccessIterator&gt;
    RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator&gt;
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&amp;&amp; exec,  <span class='comment'>// see 28.4.5
</span>                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
           class Compare&gt;
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&amp;&amp; exec,  <span class='comment'>// see 28.4.5
</span>                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp);
  template&lt;class ForwardIterator&gt;
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
                             Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                   ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                   ForwardIterator first, ForwardIterator last,
                   Compare comp);
  template&lt;class ForwardIterator&gt;
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last,
                      Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator
      is_sorted_until(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                      ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    ForwardIterator
      is_sorted_until(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                      ForwardIterator first, ForwardIterator last,
                      Compare comp);

  <span class='comment'>// 28.7.2, Nth element
</span>  template&lt;class RandomAccessIterator&gt;
    void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class RandomAccessIterator, class Compare&gt;
    void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);

  <span class='comment'>// 28.7.3, binary search
</span>  template&lt;class ForwardIterator, class T&gt;
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class T, class Compare&gt;
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T&amp; value, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class ForwardIterator, class T&gt;
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class T, class Compare&gt;
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T&amp; value, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class ForwardIterator, class T&gt;
    constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class T, class Compare&gt;
    constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T&amp; value, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class ForwardIterator, class T&gt;
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T&amp; value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class T, class Compare&gt;
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T&amp; value, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.7.5, merge
</span>  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator,
           class Compare&gt;
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator&gt;
    ForwardIterator
      merge(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare&gt;
    ForwardIterator
      merge(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result, Compare comp);

  template&lt;class BidirectionalIterator&gt;
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class BidirectionalIterator&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template&lt;class ExecutionPolicy, class BidirectionalIterator, class Compare&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);

  <span class='comment'>// 28.7.6, set operations
</span>  template&lt;class InputIterator1, class InputIterator2&gt;
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class Compare&gt;
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2,
                  Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    constexpr OutputIterator
      set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    constexpr OutputIterator
                set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator&gt;
    ForwardIterator
      set_union(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare&gt;
    ForwardIterator
      set_union(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator&gt;
    ForwardIterator
      set_intersection(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare&gt;
    ForwardIterator
      set_intersection(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator&gt;
    ForwardIterator
      set_difference(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare&gt;
    ForwardIterator
      set_difference(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator&gt;
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare&gt;
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result, Compare comp);

  <span class='comment'>// 28.7.7, heap operations
</span>  template&lt;class RandomAccessIterator&gt;
    void push_heap(RandomAccessIterator first, RandomAccessIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class RandomAccessIterator, class Compare&gt;
    void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class RandomAccessIterator&gt;
    void pop_heap(RandomAccessIterator first, RandomAccessIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class RandomAccessIterator, class Compare&gt;
    void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class RandomAccessIterator&gt;
    void make_heap(RandomAccessIterator first, RandomAccessIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class RandomAccessIterator, class Compare&gt;
    void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class RandomAccessIterator&gt;
    void sort_heap(RandomAccessIterator first, RandomAccessIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class RandomAccessIterator, class Compare&gt;
    void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class RandomAccessIterator&gt;
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class RandomAccessIterator, class Compare&gt;
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                 RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                 RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);
  template&lt;class RandomAccessIterator&gt;
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class RandomAccessIterator, class Compare&gt;
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                    RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                    RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);

  <span class='comment'>// 28.7.8, minimum and maximum
</span>  template&lt;class T&gt; constexpr const T&amp; min(const T&amp; a, const T&amp; b); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt;
    constexpr T min(initializer_list&lt;T&gt; t); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class Compare&gt;
    constexpr T min(initializer_list&lt;T&gt; t, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class T&gt; constexpr const T&amp; max(const T&amp; a, const T&amp; b); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt;
    constexpr T max(initializer_list&lt;T&gt; t); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class Compare&gt;
    constexpr T max(initializer_list&lt;T&gt; t, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class T&gt; constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  template&lt;class ForwardIterator&gt;
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator min_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    ForwardIterator min_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                ForwardIterator first, ForwardIterator last,
                                Compare comp);
  template&lt;class ForwardIterator&gt;
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator max_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    ForwardIterator max_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                ForwardIterator first, ForwardIterator last,
                                Compare comp);
  template&lt;class ForwardIterator&gt;
    constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ForwardIterator first, ForwardIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ForwardIterator first, ForwardIterator last, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                     ForwardIterator first, ForwardIterator last, Compare comp);

  <span class='comment'>// 28.7.9, bounded value
</span>  template&lt;class T&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.7.10, lexicographical comparison
</span>  template&lt;class InputIterator1, class InputIterator2&gt;
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class Compare&gt;
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2,
                              Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    bool
      lexicographical_compare(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare&gt;
    bool
      lexicographical_compare(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2,
                              Compare comp);

  <span class='comment'>// 28.7.11, three-way comparison algorithms
</span>  template&lt;class T, class U&gt;
    constexpr auto compare_3way(const T&amp; a, const U&amp; b); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class Cmp&gt;
    constexpr auto
      lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,
                                   InputIterator2 b2, InputIterator2 e2,
                                   Cmp comp)
        -&gt; common_comparison_category_t&lt;decltype(comp(*b1, *b2)), strong_ordering&gt;; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2&gt;
    constexpr auto
      lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,
                                   InputIterator2 b2, InputIterator2 e2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 28.7.12, permutations
</span>  template&lt;class BidirectionalIterator&gt;
    bool next_permutation(BidirectionalIterator first,
                          BidirectionalIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class BidirectionalIterator, class Compare&gt;
    bool next_permutation(BidirectionalIterator first,
                          BidirectionalIterator last, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class BidirectionalIterator&gt;
    bool prev_permutation(BidirectionalIterator first,
                          BidirectionalIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class BidirectionalIterator, class Compare&gt;
    bool prev_permutation(BidirectionalIterator first,
                          BidirectionalIterator last, Compare comp); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}</pre>
</blockquote>

Change in [rand.synopsis] (29.6.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>29.6.2</a> Header <span class='texttt'>&lt;random&gt;</span> synopsis <a class='abbr_ref'>[rand.synopsis]</a></h3>
<pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// 29.6.3.1, class template <span class='tcode_in_codeblock'>linear_&shy;congruential_&shy;engine</span>
</span>  template&lt;class UIntType, UIntType a, UIntType c, UIntType m&gt;
    class linear_congruential_engine; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.6.3.2, class template <span class='tcode_in_codeblock'>mersenne_&shy;twister_&shy;engine</span>
</span>  template&lt;class UIntType, size_t w, size_t n, size_t m, size_t r,
           UIntType a, size_t u, UIntType d, size_t s,
           UIntType b, size_t t,
           UIntType c, size_t l, UIntType f&gt;
    class mersenne_twister_engine; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.6.3.3, class template <span class='tcode_in_codeblock'>subtract_&shy;with_&shy;carry_&shy;engine</span>
</span>  template&lt;class UIntType, size_t w, size_t s, size_t r&gt;
    class subtract_with_carry_engine; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.6.4.2, class template <span class='tcode_in_codeblock'>discard_&shy;block_&shy;engine</span>
</span>  template&lt;class Engine, size_t p, size_t r&gt;
    class discard_block_engine; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.6.4.3, class template <span class='tcode_in_codeblock'>independent_&shy;bits_&shy;engine</span>
</span>  template&lt;class Engine, size_t w, class UIntType&gt;
    class independent_bits_engine; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.6.4.4, class template <span class='tcode_in_codeblock'>shuffle_&shy;order_&shy;engine</span>
</span>  template&lt;class Engine, size_t k&gt;
    class shuffle_order_engine; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.6.5, engines and engine adaptors with predefined parameters
</span>  using minstd_rand0  = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using minstd_rand   = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using mt19937       = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using mt19937_64    = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using ranlux24_base = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using ranlux48_base = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using ranlux24      = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using ranlux48      = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  using knuth_b       = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  using default_random_engine = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.6.6, class <span class='tcode_in_codeblock'>random_&shy;device</span>
</span>  class random_device;

  <span class='comment'>// 29.6.7.1, class <span class='tcode_in_codeblock'>seed_&shy;seq</span>
</span>  class seed_seq;

  <span class='comment'>// 29.6.7.2, function template <span class='tcode_in_codeblock'>generate_&shy;canonical</span>
</span>  template&lt;class RealType, size_t bits, class URBG&gt;
    RealType generate_canonical(URBG&amp; g);

  <span class='comment'>// 29.6.8.2.1, class template <span class='tcode_in_codeblock'>uniform_&shy;int_&shy;distribution</span>
</span>  template&lt;class IntType = int&gt;
    class uniform_int_distribution; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.6.8.2.2, class template <span class='tcode_in_codeblock'>uniform_&shy;real_&shy;distribution</span>
</span>  template&lt;class RealType = double&gt;
    class uniform_real_distribution;
</pre></blockquote>

Change in [numeric.ops.overview] (29.8.1):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>29.8.1</a> Header <span class='texttt'>&lt;numeric&gt;</span> synopsis <a class='abbr_ref'>[numeric.ops.overview]</a></h3>
<pre class='codeblock'>
namespace std {
  <span class='comment'>// 29.8.2, accumulate
</span>  template&lt;class InputIterator, class T&gt;
    T accumulate(InputIterator first, InputIterator last, T init); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class T, class BinaryOperation&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);

  <span class='comment'>// 29.8.3, reduce
</span>  template&lt;class InputIterator&gt;
    typename iterator_traits&lt;InputIterator&gt;::value_type
      reduce(InputIterator first, InputIterator last); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class T&gt;
    T reduce(InputIterator first, InputIterator last, T init); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class T, class BinaryOperation&gt; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
    T reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    typename iterator_traits&lt;ForwardIterator&gt;::value_type
      reduce(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>             ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    T reduce(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>             ForwardIterator first, ForwardIterator last, T init);
  template&lt;class ExecutionPolicy, class ForwardIterator, class T, class BinaryOperation&gt;
    T reduce(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>             ForwardIterator first, ForwardIterator last, T init, BinaryOperation binary_op);

  <span class='comment'>// 29.8.4, inner product
</span>  template&lt;class InputIterator1, class InputIterator2, class T&gt;
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class T,
           class BinaryOperation1, class BinaryOperation2&gt;
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init,
                    BinaryOperation1 binary_op1,
                    BinaryOperation2 binary_op2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.8.5, transform reduce
</span>  template&lt;class InputIterator1, class InputIterator2, class T&gt;
    T transform_reduce(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2,
                       T init); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator1, class InputIterator2, class T,
           class BinaryOperation1, class BinaryOperation2&gt;
    T transform_reduce(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2,
                       T init,
                       BinaryOperation1 binary_op1,
                       BinaryOperation2 binary_op2); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class T,
           class BinaryOperation, class UnaryOperation&gt;
    T transform_reduce(InputIterator first, InputIterator last,
                       T init,
                       BinaryOperation binary_op, UnaryOperation unary_op); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2, class T&gt;
    T transform_reduce(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2,
                       T init);
  template&lt;class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2, class T,
           class BinaryOperation1, class BinaryOperation2&gt;
    T transform_reduce(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2,
                       T init,
                       BinaryOperation1 binary_op1,
                       BinaryOperation2 binary_op2);
  template&lt;class ExecutionPolicy,
           class ForwardIterator, class T,
           class BinaryOperation, class UnaryOperation&gt;
    T transform_reduce(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                       ForwardIterator first, ForwardIterator last,
                       T init,
                       BinaryOperation binary_op, UnaryOperation unary_op);

  <span class='comment'>// 29.8.6, partial sum
</span>  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator partial_sum(InputIterator first,
                               InputIterator last,
                               OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
    OutputIterator partial_sum(InputIterator first,
                               InputIterator last,
                               OutputIterator result,
                               BinaryOperation binary_op); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.8.7, exclusive scan
</span>  template&lt;class InputIterator, class OutputIterator, class T&gt;
    OutputIterator exclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result,
                                  T init); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class OutputIterator, class T, class BinaryOperation&gt;
    OutputIterator exclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result,
                                  T init, BinaryOperation binary_op); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T&gt;
    ForwardIterator2 exclusive_scan(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                    ForwardIterator1 first, ForwardIterator1 last,
                                    ForwardIterator2 result,
                                    T init);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T,
           class BinaryOperation&gt;
    ForwardIterator2 exclusive_scan(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                    ForwardIterator1 first, ForwardIterator1 last,
                                    ForwardIterator2 result,
                                    T init, BinaryOperation binary_op);

  <span class='comment'>// 29.8.8, inclusive scan
</span>  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator inclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
    OutputIterator inclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result,
                                  BinaryOperation binary_op); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class OutputIterator, class BinaryOperation, class T&gt;
    OutputIterator inclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result,
                                  BinaryOperation binary_op, T init); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2 inclusive_scan(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                    ForwardIterator1 first, ForwardIterator1 last,
                                    ForwardIterator2 result);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation&gt;
    ForwardIterator2 inclusive_scan(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                    ForwardIterator1 first, ForwardIterator1 last,
                                    ForwardIterator2 result,
                                    BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation, class T&gt;
    ForwardIterator2 inclusive_scan(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                    ForwardIterator1 first, ForwardIterator1 last,
                                    ForwardIterator2 result,
                                    BinaryOperation binary_op, T init);

  <span class='comment'>// 29.8.9, transform exclusive scan
</span>  template&lt;class InputIterator, class OutputIterator, class T,
           class BinaryOperation, class UnaryOperation&gt;
    OutputIterator transform_exclusive_scan(InputIterator first, InputIterator last,
                                            OutputIterator result,
                                            T init,
                                            BinaryOperation binary_op,
                                            UnaryOperation unary_op); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2, class T,
           class BinaryOperation, class UnaryOperation&gt;
    ForwardIterator2 transform_exclusive_scan(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                              ForwardIterator1 first, ForwardIterator1 last,
                                              ForwardIterator2 result,
                                              T init,
                                              BinaryOperation binary_op,
                                              UnaryOperation unary_op);

  <span class='comment'>// 29.8.10, transform inclusive scan
</span>  template&lt;class InputIterator, class OutputIterator,
           class BinaryOperation, class UnaryOperation&gt;
    OutputIterator transform_inclusive_scan(InputIterator first, InputIterator last,
                                            OutputIterator result,
                                            BinaryOperation binary_op,
                                            UnaryOperation unary_op); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class OutputIterator,
           class BinaryOperation, class UnaryOperation, class T&gt;
    OutputIterator transform_inclusive_scan(InputIterator first, InputIterator last,
                                            OutputIterator result,
                                            BinaryOperation binary_op,
                                            UnaryOperation unary_op,
                                            T init); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation, class UnaryOperation&gt;
    ForwardIterator2 transform_inclusive_scan(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                              ForwardIterator1 first, ForwardIterator1 last,
                                              ForwardIterator2 result,
                                              BinaryOperation binary_op,
                                              UnaryOperation unary_op);
  template&lt;class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation, class UnaryOperation, class T&gt;
    ForwardIterator2 transform_inclusive_scan(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                              ForwardIterator1 first, ForwardIterator1 last,
                                              ForwardIterator2 result,
                                              BinaryOperation binary_op,
                                              UnaryOperation unary_op,
                                              T init);

  <span class='comment'>// 29.8.11, adjacent difference
</span>  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator adjacent_difference(InputIterator first,
                                       InputIterator last,
                                       OutputIterator result); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
    OutputIterator adjacent_difference(InputIterator first,
                                       InputIterator last,
                                       OutputIterator result,
                                       BinaryOperation binary_op); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2 adjacent_difference(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                         ForwardIterator1 first,
                                         ForwardIterator1 last,
                                         ForwardIterator2 result);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation&gt;
    ForwardIterator2 adjacent_difference(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see 28.4.5
</span>                                         ForwardIterator1 first,
                                         ForwardIterator1 last,
                                         ForwardIterator2 result,
                                         BinaryOperation binary_op);

  <span class='comment'>// 29.8.12, iota
</span>  template&lt;class ForwardIterator, class T&gt;
    void iota(ForwardIterator first, ForwardIterator last, T value); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.8.13, greatest common divisor
</span>  template&lt;class M, class N&gt;
    constexpr common_type_t&lt;M,N&gt; gcd(M m, N n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  <span class='comment'>// 29.8.14, least common multiple
</span>  template&lt;class M, class N&gt;
    constexpr common_type_t&lt;M,N&gt; lcm(M m, N n); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
}</pre>
</blockquote>

Change in [cmath.syn] (29.9.1):
<blockquote class="std">
<pre class='codeblock'>
  <span class='comment'>// 29.9.2, absolute values
</span>  int abs(int j); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  long int abs(long int j);<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  long long int abs(long long int j); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  float abs(float j);
  double abs(double j);
  long double abs(long double j);
</pre>
</blockquote>

Change in [cinttypes.syn] (30.12.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>30.12.2</a> Header <span class='texttt'>&lt;cinttypes&gt;</span> synopsis <a class='abbr_ref'>[cinttypes.syn]</a></h3>
<pre class='codeblock'>
#include &lt;cstdint&gt;  <span class='comment'>// see <a
>[cstdint.syn]</a>
</span>
namespace std {
  using imaxdiv_t = <span class='textit'><span class='texttt'>see below</span></span>; <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>

  intmax_t imaxabs(intmax_t j); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom); <ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
  intmax_t strtoimax(const char* nptr, char** endptr, int base);
  uintmax_t strtoumax(const char* nptr, char** endptr, int base);
  intmax_t wcstoimax(const wchar_t* nptr, wchar_t** endptr, int base);
  uintmax_t wcstoumax(const wchar_t* nptr, wchar_t** endptr, int base);

  intmax_t abs(intmax_t);  <span class='comment'>// optional, see below<ins><span class='textit'>, freestanding</span></ins>
</span>  imaxdiv_t div(intmax_t, intmax_t);  <span class='comment'>// optional, see below<ins><span class='textit'>, freestanding</span></ins>
</span>}
</pre>
</blockquote>

Change in [atomics.syn] (32.2):
<blockquote class="std">
<h2 ><a class='secnum' style='min-width:88pt'>32.2</a> Header <span class='texttt'>&lt;atomic&gt;</span> synopsis <a class='abbr_ref'>[atomics.syn]</a></h2>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
namespace std {
</pre>
</blockquote>

Change in [depr.cstdalign.syn] (D.4.2):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>D.4.2</a> Header <span class='texttt'>&lt;cstdalign&gt;</span> synopsis <a class='abbr_ref'>[depr.cstdalign.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define <span class='tcode_in_codeblock'>__alignas_&shy;is_&shy;defined</span> 1</pre>
</blockquote>

Change in [depr.cstdbool.syn] (D.4.3):
<blockquote class="std">
<h3 ><a class='secnum' style='min-width:103pt'>D.4.3</a> Header <span class='texttt'>&lt;cstdbool&gt;</span> synopsis <a class='abbr_ref'>[depr.cstdbool.syn]</a></h3>
<pre class='codeblock'>
<ins><span class='comment'>// <span class='textit'>freestanding</span></span></ins>
#define <span class='tcode_in_codeblock'>__bool_&shy;true_&shy;false_&shy;are_&shy;defined</span> 1</pre>
</blockquote>

<h1>Acknowledgements</h1>
<p>
Thanks to Brandon Streiff, Joshua Cannon, Phil Hindman, and Irwan Djajadi for reviewing this proposal.
</p><p>
Similar work was done in the C++11 timeframe by Lawrence Crowl and Alberto Ganesh Barbati in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3256.html">N3256</a>.
</p><p>
CppCon talks on getting C++ support in various unusual environments:
</p><p>
[Baker2017] CppCon 2017: Billy Baker "Almost Unlimited Modern C++ in Kernel-Mode Applications"
</p><p>
[Quinn2016] CppCon 2016: Rian Quinn "Making C++ and the STL Work in the Linux / Windows Kernels"
</p><p>
[Bratterud2017] CppCon 2017: Alfred Bratterud "Deconstructing the OS: The devil's In the side effects"
</p><p>
[Meredith11] noexcept Prevents Library Validation. A. Meredith; J. Lakos.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3248.pdf">N3248</a>.
</p>
</body>
</html>
